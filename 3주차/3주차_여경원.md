# CHAPTER 5: 자료 구조

## 1. 복잡도

### 1.1 시간 복잡도
- **정의**: 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계
- **빅오 표기법**: 입력 범위 n을 기준으로 로직이 몇 번 반복되는지 나타냄
- **표현**: 가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항을 없앤 것
- **존재 이유**: 효율적인 코드로 개선하는 척도
- **속도 비교**: O(1) > O(n) > O(n²) (속도 순)

### 1.2 공간 복잡도
- **정의**: 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
- 정적 변수와 동적으로 재귀적인 함수로 인한 공간 포함

### 1.3 자료 구조에서의 시간 복잡도

#### 평균 시간 복잡도
| 자료 구조 | 접근 | 탐색 | 삽입 | 삭제 |
|-----------|------|------|------|------|
| 배열 | O(1) | O(n) | O(n) | O(n) |
| 스택 | O(n) | O(n) | O(1) | O(1) |
| 큐 | O(n) | O(n) | O(1) | O(1) |
| 이중 연결 리스트 | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블 | O(1) | O(1) | O(1) | O(1) |
| 이진 탐색 트리 | O(logn) | O(logn) | O(logn) | O(logn) |

## 2. 선형 자료 구조

### 2.1 연결 리스트
- **정의**: 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조
- **시간 복잡도**: 삽입/삭제 O(1), 탐색 O(n)
- **종류**:
 - 싱글 연결 리스트: next 포인터만 가짐
 - 이중 연결 리스트: next, prev 포인터 모두 가짐
 - 원형 이중 연결 리스트: 마지막 노드의 next가 헤드를 가리킴

### 2.2 배열
- **정의**: 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터 집합
- **특징**: 중복 허용, 순서 있음, 랜덤 접근 가능
- **시간 복잡도**: 탐색 O(1), 삽입/삭제 O(n)
- **접근 방식**:
 - 랜덤 접근: 동일한 시간에 임의의 인덱스 접근 가능
 - 순차적 접근: 저장된 순서대로 검색

### 2.3 벡터
- **정의**: 동적으로 요소를 할당할 수 있는 동적 배열
- **특징**: 중복 허용, 순서 있음, 랜덤 접근 가능
- **시간 복잡도**: 탐색과 맨 뒤 삽입/삭제 O(1), 중간 삽입/삭제 O(n)
- **push_back()의 amortized 복잡도**: 평균적으로 O(1)

### 2.4 스택
- **정의**: LIFO(Last In First Out) 성질을 가진 자료 구조
- **시간 복잡도**: 삽입/삭제 O(1), 탐색 O(n)
- **용도**: 재귀 함수, 알고리즘, 웹 브라우저 방문 기록

### 2.5 큐
- **정의**: FIFO(First In First Out) 성질을 가진 자료 구조
- **시간 복잡도**: 삽입/삭제 O(1), 탐색 O(n)
- **용도**: CPU 작업 대기열, 프로세스/스레드 행렬, BFS, 캐시

## 3. 비선형 자료 구조

### 3.1 그래프
- **정의**: 정점(vertex)과 간선(edge)으로 이루어진 자료 구조
- **구성 요소**:
 - 정점: 노드
 - 간선: 정점을 연결하는 선 (단방향/양방향)
 - 가중치: 간선과 정점 사이에 드는 비용

### 3.2 트리
- **정의**: 그래프의 일종으로 계층적 데이터의 집합
- **특징**:
 - 부모-자식 계층 구조
 - V - 1 = E (간선 수 = 노드 수 - 1)
 - 임의의 두 노드 사이의 경로는 유일무이하게 존재

#### 트리의 구성
- **루트 노드**: 가장 위에 있는 노드
- **내부 노드**: 루트와 리프 사이의 노드
- **리프 노드**: 자식 노드가 없는 노드

#### 이진 트리 종류
- **정이진 트리**: 자식 노드가 0 또는 2개
- **완전 이진 트리**: 왼쪽부터 채워진 트리
- **변질 이진 트리**: 자식 노드가 하나만 있는 트리
- **포화 이진 트리**: 모든 노드가 꽉 찬 트리
- **균형 이진 트리**: 왼쪽과 오른쪽 높이 차이가 1 이하

#### 이진 탐색 트리 (BST)
- **특징**: 왼쪽 < 노드 < 오른쪽 구조
- **시간 복잡도**: 평균 O(logn), 최악 O(n)
- **문제점**: 삽입 순서에 따라 선형적 구조 가능

#### AVL 트리
- **정의**: 스스로 균형을 잡는 이진 탐색 트리
- **특징**: 두 자식 서브트리의 높이 차이가 최대 1
- **시간 복잡도**: 탐색/삽입/삭제 모두 O(logn)

#### 레드 블랙 트리
- **정의**: 균형 이진 탐색 트리
- **특징**: 각 노드가 빨간색 또는 검은색
- **용도**: C++ STL의 set, map 구현

### 3.3 힙
- **정의**: 완전 이진 트리 기반의 자료 구조
- **종류**:
 - 최대힙: 루트가 가장 큰 값
 - 최소힙: 루트가 가장 작은 값

### 3.4 우선순위 큐
- **정의**: 우선순위가 높은 요소가 먼저 제공되는 자료 구조
- **구현**: 힙을 기반으로 구현

### 3.5 맵 (Map)
- **정의**: 키와 값의 조합으로 형성된 자료 구조
- **구현**: 레드 블랙 트리 기반
- **종류**:
 - map: 정렬 보장
 - unordered_map: 해시 테이블 기반, 정렬 미보장

### 3.6 셋 (Set)
- **정의**: 고유한 요소만 저장하는 컨테이너
- **특징**: 중복 불허, 오직 unique한 값만 저장

### 3.7 해시 테이블
- **정의**: 무한에 가까운 데이터를 유한한 해시 값으로 매핑한 테이블
- **시간 복잡도**: 평균적으로 삽입/삭제/탐색 모두 O(1)
- **구현**: unordered_map으로 구현

## 예상 질문

### 1. 이진 탐색 트리의 문제점과 이를 해결하는 방법을 설명하세요.
**답변**: 이진 탐색 트리는 삽입 순서에 따라 선형적으로 구성될 때 시간 복잡도가 O(n)으로 커지는 문제점이 있습니다. 이를 해결하기 위해 AVL 트리나 레드 블랙 트리 같은 자가 균형 이진 탐색 트리를 사용합니다. AVL 트리는 두 자식 서브트리의 높이 차이를 최대 1로 유지하여 항상 O(logn)의 시간 복잡도를 보장합니다.

### 2. REST API란 무엇이고, REST에서 사용하는 HTTP 메소드인 GET과 POST의 차이점에 대해서 설명하세요.
**답변**: REST API는 자원을 URI로 표현하고 HTTP 메서드로 자원에 대한 행위를 정의하는 아키텍처 스타일입니다. 이를 일관성있게 지켜 클라이언트와 서버가 예측 가능하게 동작하는 것을 RESTful 하다고 합니다. GET은 자원을 조회할때 사용되며 여러번 호출해도 결과가 변하지않는 멱등성을 가졌지만, POST는 새로운 자원을 생성하거나 상태를 변경할 때 사용하기 때문에 멱등성이 보장되지 않습니다. 다만 조회 조건이 매우 복잡하거나 대용량 데이터를 요청 본문에 담아야 하는 경우에는 조회시에도 GET 대신 POST를 사용하기도 합니다. 이러한 경우에도 RESTful 원칙을 최대한 지키는 것이 권장됩니다.

### 3. 이러한 REST의 특징에 대해서 설명하세요.
**답변**: 첫번째로 자원 기반이라는 것입니다. 모든 데이터를 URI로 식별하며, 자원에 대한 행위는 HTTP 메서드로 표현합니다. 두번째는 Stateless 하다는 것입니다. 서버는 클라이언트의 상태를 저장하지않고, 각 요청을 독립적으로 처리합니다. 마지막으로 GET과 같은 안전한 요청은 캐시를 활용해 응답시간과 성능을 높일 수 있다는 특징이 있습니다.

### 4. html과 xml의 차이점에 대해서 설명하세요.
**답변**: html과 xml은 모두 마크업 언어지만, html은 웹 페이지의 구조와 내용을 브라우저가 보여주기 위해 태그를 미리 정의해둔 언어로, 태그 사용이 비교적 자유롭고 렌더링에 초점이 맞추어져 있습니다. 반면에 xml은 데이터를 구조화하고 교환하기 위한 목적의 언어로, 사용자가 태그를 직접 정의해서 사용할 수 있고 문법에 엄격하여 잘못된 문서는 허용하지 않습니다.

### 5. ES5애서 ES6로 올라가면서 달라진 차이점에 대해서 설명하세요.
**답변**: ES6는 ES5에 비해 문법과 기능이 개선된 버전입니다. 주된 차이점 몇가지는 ES5에서는 var만을 사용했지만 let과 const를 도입해 블록 스코프 변수 선언이 가능하게 되었고, 화살표함수를 도입하여 간경하게 함수를 작성할 수 있게 되었습니다. 이밖에도 this 바인딩, 백틱을 사용해 문자열 내 변수와 표현식을 쉽게 삽입할 수 있는 템플릿 리터럴, 클래스와 모듈 지원, promise 등의 비동기 처리 기능이 추가되었습니다.

### 6. CORS에 대해서 설명하세요.
**답변**: CORS는 한 도메인의 웹 애플리케이션이 다른 도메인의 자원에 접근할 수 있도록 허용하는 브라우저 보안 정책입니다. 백엔드와 프론트엔드를 개발하게되면 각각 다른 서버 도메인을 가지고있을텐데, 백엔드에서 CORS 설정을 통해 서버가 특정 출처를 허용하도록 설정하면 프론트엔드에서 서로 다른 도메인이더라도 안전하게 데이터를 주고받을 수 있게됩니다.

### 7. 브라우저의 동작에 대해서 설명하세요.
**답변**: 사용자가 URL을 입력하면 해당 서버에 요청을 보내고, 서버에서 html, css, 이미지 등의 다양한 자원을 받아 화면에 표시합니다. 브라우저는 렌더링 엔지을 통해 html을 파싱하고 DOM 트리를 생성하며, css를 함께 파싱해 스타일 정보를 결합한 렌더 트리를 만듭니다. 이후 렌더 트리를 기반으로 배치와 그리기 과정을 거쳐 화면에 시각적으로 표시하게 됩니다.

### 8. 쿠키와 세션에 대한 짧은 설명과 차이점, 그리고 각각의 활용방안에 대해서 설명하세요.
**답변**: 쿠키는 클라이언트쪽의 브라우저에 저장되는 작은 데이터로, 주로 로그인 상태 유지나 사용자 설정 저장에 사용됩니다. 반면 세션은 서버쪽에 저장되는 사용자 정보로, 로그인 상태나 장바구니 등 안전하게 데이터를 유지할때 사용합니다. 가장 큰 차이점은 저장 위치와 보안성에 있는데, 쿠키는 클라이언트에 저장되기 때문에 보안이 낮고 용량이 제한적이지만, 세션은 서버에 저장되어 안정하고 비교적 큰 데이터를 관리할 수 있다는 점입니다.

### 9. 웹 서버와 WAS의 차이점에 대해서 설명하세요.
**답변**: 웹 서버는 클라이언트가 요청한 html, css, js 등의 정적자원을 그대로 전달하는 역할을 합니다. 반면 WAS는 동적인 요청을 처리할 수 있는 서버로, 자바 서블릿이나 jsp 같은 애플리케이션 로직을 실행하여 동적 html을 생성합니다. 즉, 웹서버는 콘텐츠의 전달, WAS는 비지니스 로직 실행과 동적 콘텐츠의 생성을 담당한다고 정리할 수 있습니다.

### 10. CSR과 SSR의 차이점에 대해서 설명하세요.
**답변**: CSR은 서버에서 최소한의 html과 스크립트만 받아 브라우저가 화면을 렌더링하는 방식입니다. 반면 SSR은 서버에서 html을 미리 생성해서 클라이언트에 전달하기는 방식이기 때문에 초기 화면 로드가 빠르고, 검색 엔진이 내용을 쉽게 인식할 수 있습니다. 그래서 최근에는 SPA 방식을 통해 웹을 많이 작성하게 되는데, 보통 CSR을 사용해 화면을 랜더링하지만, 초기 로딩 속도가 느리고 검색 엔진이 내용을 바로 인식하기 어렵다는 단점이 있습니다. 그래서 모든 요청에 SSR만을 사용하면 좋다고 생각할 수 있지만, 그렇게되면 요청마다 서버가 html을 생성해야하기 때문에 서버의 부하가 증가하게 됩니다. 따라서 SPA 방식에서 초기 로딩과 검색 노출이 중요한 경우 SSR 방식을 선별적으로 사용하면서, 동적 화면 처리는 CSR과 혼합해 사용하는 것이 효과적입니다.

### 11. Vue와 React에서 상태관리를 어떻게 하는지 차이점에 대해서 설명하세요.
**답변**: Vue는 컴포넌트 내부상태를 data()나 reactive, ref로 관리하고, 컴포넌트간 전역 상태는 Vuex나 Composition API로 관리합니다. 반면 React를 컴포넌트 내부 상태를 useState로 관리하고, 전역 상태는 Context API나 Redux 같은 외부 라이브러리를 통해 관리하는 방식을 사용합니다.

### 12. 이벤트 버블링, 이벤트 캡처링, 이벤트 위임에 대해서 설명하세요.
**답변**: 이벤트 버블링은 이벤트가 자식 요소에서 부모 요소로 전달되는 방식으로 대부분의 브라우저 기본동작이 버블링으로 되어있습니다. 반대로 이벤트 캡처링은 부모에서 자식으로 전달되는 방식으로, 자식보다 부모에서 먼저 이벤트를 처리해야 하는 겅우에 사용되며 많이 쓰이지는 않는다고 알고있습니다. 이벤트 위임은 부모 요소에 이벤트를 등록해 다수의 자식 요소 이벤트를 한번에 처리하는 기법으로, 동적 요소 처리나 메모리 효율에 유리합니다. 제가 최종 프로젝트에서 드래그앤드롭 이벤트를 구현시에 자식요소에서 부모 요소로 전파되는 버블링 때문에 의도치 않은 동작이 발생할 수 있어, 프로파게이션을 차단하여 구현했던 경험이 있습니다.
