# 2주차 스터디 정리

## 범위

**1. 운영체재**

**2. 데이터베이스**

## 발표자

- 운영체재 : 배상현
- 데이터베이스 : 백승호

## 진행 날짜

- 2025년 8월 13일

## 예상 질문 내용 및 답변

### 1. 식별 관계와 비식별 관계의 차이

### 식별 관계 (Identifying Relationship)

- **정의**: 부모 테이블의 기본키가 자식 테이블의 기본키의 일부가 되는 관계
- **특징**: 자식 테이블의 기본키가 부모 테이블의 기본키를 포함
- **ERD 표현**: 실선으로 표현
- **예시**: 주문(주문번호) - 주문상세(주문번호, 상품번호)

### 비식별 관계 (Non-identifying Relationship)

- **정의**: 부모 테이블의 기본키가 자식 테이블의 일반 속성(외래키)이 되는 관계
- **특징**: 자식 테이블이 독립적인 기본키를 가짐
- **ERD 표현**: 점선으로 표현
- **예시**: 부서(부서번호) - 직원(직원번호, 부서번호)

---

### 2. 멀티프로세스와 멀티스레드의 차이점

### 멀티프로세스 (Multi-Process)

**정의**: 여러 개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행하는 것

**특징**:

- 각 프로세스는 독립적인 메모리 공간(코드, 데이터, 스택, 힙) 보유
- 프로세스 간 통신은 IPC(Inter Process Communication) 필요
- 한 프로세스 오류가 다른 프로세스에 영향을 주지 않음 (높은 안정성)
- 컨텍스트 스위칭 비용이 높음

### 멀티스레드 (Multi-Threading)

**정의**: 프로세스 내 작업을 여러 개의 스레드로 처리하는 기법

**특징**:

- 코드, 데이터, 힙 영역을 공유하고 스택 영역만 개별 생성
- 스레드 간 데이터 공유가 쉬움 (별도 통신 기법 불필요)
- 한 스레드 오류가 전체 프로세스에 영향 (낮은 안정성)
- 컨텍스트 스위칭 비용이 낮음

---

## 3. 프로세스와 스레드의 차이

### 프로세스 (Process)

- **정의**: 컴퓨터에서 실행되고 있는 프로그램, CPU 스케줄링의 대상이 되는 작업
- **메모리 구조**: 독립적인 코드, 데이터, 스택, 힙 영역 보유
- **통신 방법**: IPC (공유 메모리, 파이프, 소켓, 메시지 큐 등)
- **생성 비용**: 높음
- **안정성**: 높음 (독립적 실행)

### 스레드 (Thread)

- **정의**: 프로세스의 실행 가능한 가장 작은 단위
- **메모리 구조**: 스택만 개별 생성, 나머지는 프로세스 내에서 공유
- **통신 방법**: 메모리 공유를 통한 직접 통신
- **생성 비용**: 낮음
- **안정성**: 낮음 (공유 자원으로 인한 문제 발생 가능)

---

## 4. 운영체제에서 페이징이란 무엇이고 왜 사용하는가?

### 페이징 (Paging)

**정의**: 가상 메모리를 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당하는 메모리 관리 기법

### 사용 이유

1. **외부 단편화 해결**: 고정된 크기로 메모리를 나누어 외부 단편화 문제 해결
2. **메모리 효율성**: 프로세스 전체를 메모리에 올리지 않고 필요한 페이지만 로드
3. **가상 메모리 구현**: 물리 메모리보다 큰 프로그램 실행 가능
4. **메모리 보호**: 프로세스 간 메모리 영역 침범 방지

### 동작 과정

- MMU(Memory Management Unit)가 가상 주소를 물리 주소로 변환
- 페이지 테이블을 통해 가상 페이지와 물리 프레임 매핑
- TLB(Translation Lookaside Buffer)로 주소 변환 속도 향상

---

## 5. 인덱스가 무엇이고 무조건 사용하는 것이 좋은가?

### 인덱스 (Index)

**정의**: 데이터베이스에서 검색 속도를 향상시키기 위해 사용하는 별도의 데이터 구조

### 장점

- **검색 속도 향상**: O(log n) 시간 복잡도로 빠른 검색
- **정렬 효율성**: ORDER BY 절 성능 향상
- **조인 성능 향상**: 외래키에 인덱스 생성 시 조인 속도 개선

### 단점

- **저장 공간**: 추가 저장 공간 필요 (테이블 크기의 10% 내외)
- **DML 성능 저하**: INSERT, UPDATE, DELETE 시 인덱스도 함께 수정해야 하므로 속도 저하
- **유지보수 비용**: 인덱스 관리를 위한 추가 작업 필요

### 결론

**무조건 사용하는 것은 좋지 않음**

- 읽기 작업이 많고 쓰기 작업이 적은 테이블에 효과적
- 카디널리티가 높은 컬럼(중복값이 적은)에 생성하는 것이 효율적
- 테이블 크기와 사용 패턴을 고려하여 선택적으로 사용해야 함

---

## 6. 내부 단편화란 무엇인가?

### 내부 단편화 (Internal Fragmentation)

**정의**: 메모리를 나눈 크기보다 프로그램이 작아서 할당된 메모리 블록 내에서 사용되지 않는 공간이 발생하는 현상

### 발생 원인

- **고정 분할 방식**: 메모리를 미리 고정된 크기로 나누어 관리할 때
- **페이징 시스템**: 마지막 페이지가 페이지 크기보다 작을 때

### 예시

- 100KB 메모리 블록에 80KB 프로그램 할당 → 20KB 내부 단편화 발생
- 4KB 페이지에 3KB 데이터 저장 → 1KB 내부 단편화 발생

### 해결 방법

- **가변 분할 방식** 사용
- **적절한 페이지 크기** 설정
- **세그멘테이션** 기법 활용

---

## 7. VARCHAR와 TEXT의 차이

### VARCHAR

- **정의**: 가변 길이 문자열 데이터 타입
- **최대 길이**: 보통 255자 또는 65,535자까지 (DBMS별 상이)
- **길이 제한**: 생성 시 최대 길이를 명시해야 함 (예: VARCHAR(100))
- **인덱스**: 전체 길이에 대해 인덱스 생성 가능
- **성능**: 상대적으로 빠름
- **사용 예시**: 이름, 이메일, 제목 등 길이가 예측 가능한 데이터

### TEXT

- **정의**: 긴 문자열 데이터를 저장하는 데이터 타입
- **최대 길이**: 매우 큰 용량 지원 (LONGTEXT의 경우 4GB)
- **길이 제한**: 명시하지 않음
- **인덱스**: 일부분에 대해서만 인덱스 생성 가능
- **성능**: 상대적으로 느림 (별도 저장 공간 사용)
- **사용 예시**: 게시글 내용, 설명, 로그 데이터 등

---

## 8. BLOB을 사용하지 않는 이유

### BLOB (Binary Large Object)

**정의**: 이미지, 비디오, 오디오 등의 바이너리 데이터를 저장하는 데이터 타입

### 사용하지 않는 이유

**1. 성능 문제**

- 데이터베이스 크기 급격히 증가
- 백업/복구 시간 오래 소요
- 메모리 사용량 증가로 전체 시스템 성능 저하

**2. 확장성 문제**

- 데이터베이스 서버에 부하 집중
- 분산 처리 어려움
- 캐싱 효율성 떨어짐

**3. 관리 복잡성**

- 데이터베이스 관리 복잡
- 트랜잭션 처리 시 큰 오버헤드
- 동시성 제어 어려움

**4. 네트워크 부하**

- 대용량 데이터 전송으로 네트워크 대역폭 소모
- 응답 시간 지연

### 대안책

- **파일 시스템 저장**: 실제 파일은 파일 시스템에 저장하고 DB에는 경로만 저장
- **CDN 활용**: 정적 파일을 CDN에 업로드하고 URL만 DB에 저장
- **클라우드 스토리지**: AWS S3, Google Cloud Storage 등 활용
- **전용 파일 서버**: 별도의 파일 서버 구축하여 관리
