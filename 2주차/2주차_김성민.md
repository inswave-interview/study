## 3.1.1 운영체제의 역할과 구조

### 역할

1. CPU 스케줄링과 프로세스 관리
2. 메모리 관리
3. 디스크 파일 관리
4. 입출력 장치 관리

### 구조

인터페이스(GUI,CUI), 시스템콜, 커널

**시스템콜?**

- 운영체제가 커널에 접근하기 위한 인터페이스
- 유저모드와 커널모드로 구성
- 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용
- modebit 이란 값을 이용해 유저모드와 커널모드를 구분함

![[modebit.png]]

---

## 3.1.2 컴퓨터의 요소

### CPU

프로그램의 명령어를 해석하고 실행하는 장치
제어장치, 연산장치, 레지스터로 구성

**제어장치**

- 메모리에서 명령어를 가져와서 해석
- 명령어 실행을 위해 필요한 부품들에게 제어 신호 전송
- 프로그램 카운터(PC)로 다음 실행할 명령어 주소 관리
- 명령어 실행 순서와 타이밍 제어
  **레지스터**
- CPU 내부의 초고속 임시 저장소
- CPU의 자체 메모리가 없으므로 레지스터를 활용하여 메모리에 전달
  **연산장치**
- 실제 계산과 논리 연산을 수행하는 계산기
- 산술, 논리, 비교, 시프트 연산등을 수행

**인터럽트**
인터럽트는 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것을 말함
키보드, 마우스 등 IO 디바이스로 인한 하드웨어 인터럽트
0으로 숫자를 나누는 산술 연산에서의 인터럽트, 프로세스 오류 등의 소프트웨어 인터럽트가 있다

### DMA 컨트롤러

DMA 컨트롤러는 I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치를 뜻한다

### 메모리

메모리(memory)는 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치를 말하며
보통 RAM(Random Access Memory)을 일컬어 메모리라고 한다
CPU는 계산을 담당하고 메모리는 기억을 담당한다

---

## 3.2.1 메모리 계층

메모리는 **계층적 구조**로 이루어져 있으며, 위로 올라갈수록 **가격은 비싸지고 용량은 작아지지만 속도는 빨라진다**

**레지스터**

- CPU 안에 있는 작은 메모리
- 휘발성, 속도가 가장 빠르며 기억 용량이 가장 적음
- CPU의 자체 메모리 역할
  **캐시**
- L1, L2 캐시를 지칭
- 휘발성, 속도 빠름, 기억 용량이 적음
- CPU와 메모리 사이의 속도 차이를 해결하는 중간 계층
  **주기억장치(RAM)**
- 휘발성, 속도 보통, 기억 용량도 보통
- 하드디스크로부터 데이터를 복사해서 임시 저장
- 필요시마다 CPU에 빠르게 전달하는 역할
  **보조기억장치(HDD, SSD)**
- 비휘발성, 속도 낮음, 기억용량이 많음
- 영구적 데이터 저장

### 캐시(Cache)

데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리

**캐싱 계층**: 속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층

- 예: 주기억장치는 보조기억장치의 캐싱 계층

### 지역성의 원리

캐시를 효과적으로 사용하기 위한 근거가 되는 원리

**시간 지역성(Temporal Locality)**

- 최근 사용한 데이터에 다시 접근하려는 특성

**공간 지역성(Spatial Locality)**

- 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

### 캐시 동작

**캐시 히트**: 캐시에서 원하는 데이터를 찾은 경우
**캐시 미스**: 해당 데이터가 캐시에 없어서 주 메모리로 가서 데이터를 찾아오는 경우

### 캐시 매핑 방식

CPU의 레지스터와 주 메모리(RAM) 간에 데이터를 주고받을 때 사용하는 매핑 방법

**직접 매핑(Direct Mapping)**

- 메모리가 1~100, 캐시가 1~10이면 1:1~10, 2:1~20 방식으로 매핑
- 처리가 빠르지만 충돌 발생이 잦음

**연관 매핑(Associative Mapping)**

- 순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑
- 충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느림

**집합 연관 매핑(Set Associative Mapping)**

- 직접 매핑과 연관 매핑을 합친 방식
- 순서는 일치시키지만 집합을 둬서 저장하며 블록화되어 있어 검색이 효율적
- 예: 캐시 1~5에는 1~50의 데이터를 무작위로 저장

---

## 3.2.2 메모리 관리

### 가상 메모리(Virtual Memory)

컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 사용자들에게 매우 큰 메모리로 보이게 만드는 메모리 관리 기법

**가상 주소(Logical Address)**: 가상적으로 주어진 주소
**실제 주소(Physical Address)**: 실제 메모리상에 있는 주소
**MMU(Memory Management Unit)**: 가상 주소를 실제 주소로 변환하는 메모리 관리 장치

**페이지 테이블**: 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 테이블
**페이지** : 가상 메모리를 사용하는 최소 크기 단위

**TLB(Translation Lookaside Buffer)**

- 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시
- 페이지 테이블에 있는 리스트를 보관
- CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시키는 캐시 계층

### 스와핑(Swapping)

가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우, 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것

### 페이지 폴트(Page Fault)

프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우에 발생

**처리 과정**

1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생해서 운영체제에 알림
2. 운영체제는 CPU의 동작을 잠시 멈춤
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 물리 메모리에 비어 있는 프레임이 있는지 확인 (없다면 스와핑 발동)
4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화
5. 중단되었던 CPU를 다시 시작

### 스레싱(Thrashing)

메모리의 페이지 폴트율이 높은 것으로, 컴퓨터의 심각한 성능 저하를 초래

**발생 원인**: 메모리에 너무 많은 프로세스가 동시에 올라가면 스와핑이 많이 일어남

**해결 방법**:

- **하드웨어적**: 메모리 증설, HDD를 SSD로 교체
- **소프트웨어적**: 작업 세트, PFF 방법 사용

**작업 세트(Working Set)**
프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 미리 메모리에 로드

**PFF(Page Fault Frequency)**
페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만들어 프레임 수를 조절

### 메모리 할당

#### 연속 할당

메모리에 연속적으로 공간을 할당하는 방식

**고정 분할 방식(Fixed Partition Allocation)**

- 메모리를 미리 나누어 관리
- 융통성이 없고 내부 단편화 발생

**가변 분할 방식(Variable Partition Allocation)**

- 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용
- 내부 단편화는 발생하지 않지만 외부 단편화 발생 가능

**가변 분할 방식의 종류**:

- **최초 적합(First Fit)**: 위쪽이나 아래쪽부터 홀을 찾으면 바로 할당
- **최적 적합(Best Fit)**: 프로세스 크기 이상인 공간 중 가장 작은 홀부터 할당
- **최악 적합(Worst Fit)**: 프로세스 크기와 가장 많이 차이가 나는 홀에 할당

#### 불연속 할당

메모리를 연속적으로 할당하지 않는 방식 (최신)

**페이징(Paging)**

- 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
- 홀의 크기가 균일하지 않은 문제 해결, 하지만 주소 변환이 복잡

**세그멘테이션(Segmentation)**

- 의미 단위인 세그먼트로 나누는 방식
- 코드, 데이터, 스택, 힙 등으로 나누거나 함수 단위로 분할
- 공유와 보안 측면에서 좋지만 홀 크기가 균일하지 않은 문제 발생

**페이지드 세그멘테이션(Paged Segmentation)**

- 공유나 보안을 의미 단위의 세그먼트로 나누고 물리적 메모리는 페이지로 나누는 방식

### 페이지 교체 알고리즘

메모리가 한정되어 있기 때문에 스와핑을 최소화하기 위한 알고리즘

**오프라인 알고리즘(Offline Algorithm)**

- 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘
- 가장 좋은 방법이지만 실제로는 사용할 수 없음 (성능 비교 기준 제공)

**FIFO(First In First Out)**

- 가장 먼저 온 페이지를 교체 영역에 가장 먼저 배치

**LRU(Least Recently Used)**

- 참조가 가장 오래된 페이지를 교체
- 각 페이지마다 계수기, 스택을 두어야 하는 문제점 존재
- 해시 테이블과 이중 연결 리스트로 구현

**NUR(Not Used Recently)/Clock Algorithm**

- 참조되지 않음을 뜻하는 0과 최근에 참조된 1을 가진 비트를 두고 시계방향으로 돌면서 0을 찾아 교체

**LFU(Least Frequently Used)**

- 가장 참조 횟수가 적은 페이지를 교체

**용어 정리**

- **내부 단편화**: 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상
- **외부 단편화**: 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상
- **홀(Hole)**: 할당할 수 있는 비어있는 메모리 공간
- **페이지**: 가상 메모리를 사용하는 최소 크기 단위
- **프레임**: 실제 메모리를 사용하는 최소 크기 단위

---

## 3.3 프로세스와 스레드

### 프로세스(Process)

**정의**: 컴퓨터에서 실행되고 있는 프로그램을 말하며, CPU 스케줄링의 대상이 되는 작업(Task)

**프로그램 vs 프로세스**:

- **프로그램**: 구글 크롬 프로그램(Chrome.exe)과 같은 실행 파일
- **프로세스**: 프로그램을 두 번 클릭하면 시작되는 구글 크롬 '프로세스'
- 프로그램이 메모리에 올라가면 프로세스가 되는 **인스턴스화** 발생

## 3.3.1 프로세스 컴파일 과정

소스코드가 실행 가능한 프로그램이 되는 4단계 과정

**1. 전처리(Preprocessing)**

- 소스코드의 주석 제거
- #include 등 헤더 파일을 병합하여 매크로 치환

**2. 컴파일러(Compiler)**

- 오류 처리, 코드 최적화 작업
- 어셈블리어로 변환

**3. 어셈블러(Assembler)**

- 어셈블리어를 목적 코드(Object Code)로 변환
- 리눅스에서는 '.o' 확장자 파일 생성 (예: Bar.c → Bar.o)

**4. 링커(Linker)**

- 프로그램 내 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합
- 실행 파일 생성 (확장자: '.exe' 또는 '.out')

### 라이브러리

**정적 라이브러리(Static Library)**

- 프로그램 빌드 시 라이브러리의 모든 코드를 실행 파일에 포함
- 장점: 시스템 환경 등의 외부 의존도가 낮음
- 단점: 코드 중복 등으로 메모리 효율성이 떨어짐

**동적 라이브러리(Dynamic Library)**

- 프로그램 실행 시 필요할 때만 DLL 함수 정보를 통해 참조
- 장점: 메모리 효율성이 좋음
- 단점: 외부 의존도가 높아짐

## 3.3.2 프로세스의 상태

**생성 상태(Create)**

- 프로세스가 생성된 상태
- `fork()` 또는 `exec()` 함수를 통해 생성
- 이때 PCB(Process Control Block)가 할당됨
- **대기 상태(Ready)**
- 메모리 공간이 충분하면 메모리를 할당받고 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태

**대기 중단 상태(Ready Suspended)**

- 메모리 부족으로 일시 중단된 상태

**실행 상태(Running)**

- CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태
- **CPU Burst**가 일어났다고 표현

**중단 상태(Blocked)**

- 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태
- I/O 디바이스에 의한 인터럽트로 발생
- 예: 프린트 인쇄 버튼을 눌렀을 때 프로세스가 잠깐 멈춘 상태

**일시 중단 상태(Blocked Suspended)**

- 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태

**종료 상태(Terminated)**

- 메모리와 CPU 소유권을 모두 놓고 가는 상태
- 자연스러운 종료 또는 부모 프로세스에 의한 강제 종료(Abort)

### 3.3.3 프로세스의 메모리 구조

운영체제는 프로세스에 다음 구조를 기반으로 메모리를 할당

**스택(Stack)** - 위 주소부터 할당

- 지역변수, 매개변수, 함수가 저장
- 컴파일 시에 크기가 결정되며 **동적**인 특징
- 함수 재귀 호출 시 동적으로 크기 증가 가능

**힙(Heap)** - 아래 주소부터 할당

- 동적 할당할 때 사용되며 런타임 시 크기가 결정
- 예: 벡터 같은 동적 배열
- **동적**인 특징을 가짐

**데이터 영역(Data Segment)**

- 전역 변수, 정적 변수가 저장
- **정적**인 특징, 프로그램 종료 시 사라짐
- **BSS 영역**: 초기화되지 않은 변수가 0으로 초기화되어 저장
- **Data 영역**: 0이 아닌 다른 값으로 할당된 변수들이 저장

**코드 영역(Code Segment)**

- 프로그램에 내장되어 있는 소스코드가 들어가는 영역
- 수정 불가능한 기계어로 저장
- **정적**인 특징

### PCB (Process Control Block)

**정의**: 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터 구조
**역할**

- 프로세스가 생성되면 운영체제가 해당 PCB를 생성
- 프로세스의 중요한 정보를 포함하므로 커널 스택의 가장 앞부분에서 관리

**PCB에 저장되는 정보**

- **프로세스 스케줄링 상태**: '준비', '일시 중단' 등의 상태 정보
- **프로세스 ID**: 프로세스 ID, 해당 프로세스의 자식 프로세스 ID
- **프로세스 권한**: 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
- **프로그램 카운터**: 프로세스에서 실행해야 할 다음 명령어의 주소 포인터
- **CPU 레지스터**: 프로세스를 실행하기 위해 저장해야 할 레지스터 정보
- **CPU 스케줄링 정보**: CPU 스케줄러에 의해 중단된 시간 등의 정보
- **계정 정보**: 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
- **I/O 상태 정보**: 프로세스에 할당된 I/O 디바이스 목록

### 컨텍스트 스위칭 (Context Switching)

**정의**: PCB를 교환하는 과정으로, 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생

**동작 과정**

1. 프로세스 A 실행 중 시간 할당량 종료 또는 인터럽트 발생
2. 프로세스 A의 PCB를 저장
3. 프로세스 B의 PCB를 로드하여 실행
4. 프로세스 B 실행 완료 후 프로세스 B의 PCB 저장
5. 프로세스 A의 PCB를 다시 로드

**컨텍스트 스위칭 비용**:

- **유휴 시간(Idle Time)**: 실제 작업이 수행되지 않는 시간 발생
- **캐시 미스(Cache Miss)**: 프로세스가 바뀌면서 캐시 클리어 과정 필요

**스레드에서의 컨텍스트 스위칭**:

- 스레드는 스택 영역을 제외한 모든 메모리를 공유
- 프로세스 컨텍스트 스위칭보다 비용이 적고 시간도 더 적게 소요

---

## 3.3.5 멀티 프로세싱

**정의**: 여러 개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것

**장점**

- 하나 이상의 일을 병렬로 처리 가능
- 특정 프로세스에 문제가 발생해도 다른 프로세스로 처리 가능하여 **신뢰성이 높음**

### IPC (Inter Process Communication)

**정의**: 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘
**특징**: 모든 IPC 방식은 메모리가 완전히 공유되는 스레드보다는 속도가 떨어짐

#### IPC 종류

**1. 공유 메모리(Shared Memory)**

- 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한 부여
- 공유 버퍼를 생성하여 프로세스가 서로 통신
- **가장 빠른 IPC 방식** (불필요한 데이터 복사 오버헤드 없음)
- 동기화 필요

**2. 파일(File)**

- 디스크에 저장된 데이터 또는 파일 서버에서 제공한 데이터 기반 통신

**3. 소켓(Socket)**

- 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송되는 데이터
- TCP와 UDP 방식 존재

**4. 익명 파이프(Unnamed Pipe)**

- 프로세스 간에 FIFO 방식으로 읽히는 임시 공간인 파이프 기반 데이터 통신
- **단방향 방식**의 읽기 전용 파이프
- 부모-자식 프로세스 간에만 사용 가능, 네트워크상에서는 사용 불가

**5. 명명된 파이프(Named Pipe)**

- 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 명명된 단방향 또는 이중 파이프
- 여러 파이프를 동시 사용 가능
- 컴퓨터의 프로세스끼리 또는 다른 네트워크상의 컴퓨터와도 통신 가능

**6. 메시지 큐(Message Queue)**

- 메시지를 큐 데이터 구조 형태로 관리
- 커널에서 전역적으로 관리
- 사용 방법이 직관적이고 간단
- 공유 메모리의 동기화 복잡성 대안으로 사용

---

## 3.3.6 스레드와 멀티스레딩

### 스레드(Thread)

프로세스의 실행 가능한 가장 작은 단위

**메모리 구조**

- **공유**: 코드, 데이터, 힙 영역을 스레드끼리 서로 공유
- **개별**: 스택 영역은 각각 생성

**프로세스와의 차이**

- 프로세스: 코드, 데이터, 스택, 힙을 각각 생성
- 스레드: 스택만 개별 생성, 나머지는 공유

### 멀티스레딩 (Multithreading)

프로세스 내 작업을 여러 개의 스레드로 처리하는 기법

**장점**

- **효율성**: 스레드끼리 서로 자원을 공유하므로 효율성이 높음
- **리소스 절약**: 새 프로세스 생성 대신 스레드 사용 시 훨씬 적은 리소스 소비
- **빠른 처리**: 한 스레드가 중단되어도 다른 스레드는 실행 상태 유지 가능
- **동시성**: 서로 독립적인 작업들을 동시에 실행되는 것처럼 처리

**단점**

- **안정성 문제**: 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 전체 프로세스에 영향 가능

---

## 3.3.7 공유 자원과 임계 영역

### 공유 자원(Shared Resource)

시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수

**경쟁 상태(Race Condition)**: 두 개 이상의 프로세스가 공유 자원을 동시에 읽거나 쓰는 상황

### 임계 영역(Critical Section)

공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역

**해결 조건**

- **상호 배제**: 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없음
- **한정 대기**: 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 됨
- **융통성**: 한 프로세스가 다른 프로세스의 일을 방해해서는 안 됨

### 동기화 방법

#### 1. 뮤텍스(Mutex)

공유 자원을 사용하기 전에 설정하고 사용한 후에는 해제하는 잠금

**특징**

- 잠금이 설정되면 다른 스레드는 잠긴 코드 영역에 접근 불가
- 하나의 상태(잠금 또는 잠금 해제)만 가짐

#### 2. 세마포어(Semaphore)

일반화된 뮤텍스로, 간단한 정수 값과 두 가지 함수로 공유 자원에 대한 접근을 처리

**함수**

- **wait()**: 자신의 차례가 올 때까지 기다리는 함수
- **signal()**: 다음 프로세스로 순서를 넘겨주는 함수

**종류**

- **바이너리 세마포어**: 0과 1의 두 가지 값만 가질 수 있는 세마포어
- **카운팅 세마포어**: 여러 개의 값을 가질 수 있으며, 여러 자원에 대한 접근을 제어

#### 3. 모니터(Monitor)

둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대한 인터페이스만 제공

**특징**

- 모니터 큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리
- 세마포어보다 구현하기 쉬움
- 상호 배제가 자동으로 이루어짐 (세마포어는 명시적 구현 필요)

---

## 3.3.8 교착상태 (Deadlock)

두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

### 교착상태의 원인 (4가지 조건)

1. **상호 배제**: 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근 불가
2. **점유 대기**: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태
3. **비선점**: 다른 프로세스의 자원을 강제적으로 가져올 수 없음
4. **환형 대기**: 프로세스들이 서로가 서로의 자원을 요구하는 상황

### 교착상태의 해결방법

1. **예방**: 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계
2. **회피**: 교착상태 가능성이 없을 때만 자원 할당 (은행원 알고리즘)
3. **탐지**: 교착상태가 발생하면 사이클을 찾아 관련된 프로세스를 하나씩 제거
4. **무시**: 교착상태가 매우 드물게 발생하므로 발생 시 사용자가 작업을 종료

**현대 운영체제**는 **4번 방법을 채택** - 예: '응답 없음' 상태 발생 시 사용자가 직접 종료

**은행원 알고리즘**: 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘

---

## 3.4 CPU 스케줄링 알고리즘

## 3.4.1 비선점형 방식

- 프로세스가 스스로 CPU 소유권을 포기하는 방식
- 운영체제가 강제로 중지하지 않음
- 컨텍스트 스위칭 부하가 적음
- FCFS, SJF, 우선순위

## 3.4.2 선점형 방식

- 현대 운영체제 사용 방식
- 알고리즘에 의해 프로세스를 중단시키고 다른 프로세스를 할당하는 방식

### 라운드로빈

각 프로세스에 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘
로드밸런서에 트래픽 분산 알고리즘으로도 사용

### SRF

짧은 시간이 소요되는 작업을 우선적으로 수행하는 알고리즘

### 다단계 큐

우선순위에 따른 준비 큐를 여러개 사용하여 각각 다른 알고리즘을 사용하는 방식
스케쥴링 부담은 적지만 유연성은 떨어진다

---

## 4.1 데이터베이스 기본

데이터베이스는 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음이다
**DBMS** : 데이터베이스를 제어, 관리하는 통합 시스템

## 4.1.1 엔티티

데이터베이스에서 **독립적으로 존재하는 실체나 객체**를 의미
현실 세계의 사물, 개념, 사건 등을 데이터베이스에서 표현한 것
**특징**

- 독립적으로 존재
- 고유한 식별자를 가짐
- 속성을 보유함
- 독립적으로 존재하면 강한 엔티티, 그렇지않다면 약한 엔터티

## 4.1.2 릴레이션

데이터베이스에서 정보를 구분하여 저장하는 기본 단위
관계형 데이터베이스에선 테이블, NoSql 데이터베이스에서는 컬렉션

## 4.1.3 속성

엔터티나 릴레이션이 가지는 **고유한 특성이나 성질**을 의미
엔터티를 구체적으로 설명하고 식별할 수 있게 해주는 데이터 항목
**특징**

- 더 이상 분해되지 않는 최소 단위의 정보
- 엔티티의 세부사항
- 실제 저장될 데이터의 종류를 나타냄
- 기본키 속성, 일반 속성, 단순/복합 속성

## 4.1.4 도메인

각각의 속성이 가질 수 있는 값의 집합
주민등록번호의 도메인 : 생년월일 - 1,2 남여구분, 지역구분 등
학년의 도메인 : {1,2,3,4}

## 4.1.5 필드와 레코드

![[Pasted image 20250812222306.png]]

- 회원이란 `엔티티`는 member라는 `테이블`로 `속성`인 이름, 아이디 등을 가지고 있으며 name, ID, address 등의 `필드`를 가진다
- 이 테이블에 쌓이는 행(row) 단위의 데이터를 `레코드`라고 한다
- `레코드`를 `튜플`이라고도 한다

## 4.1.6 관계

여기서의 관계는 관계형 데이터베이스의 릴레이션이 아니라 엔터티 간의 관계를 의미함

### 일대일 관계

- 사람 <-> 주민번호
- 학생 <-> 학생증

### 일대다 관계

- 부서 <-> 직원
- 고객 <-> 주문
- 교수 <-> 학생

### 다대다 관계

다대다 관계의 실제 구성은 중간에 매핑 테이블을 활용하여 일대다 관계로 풀어서 표현한다

- 학생 <-> 강의
  - 학생도 강의를 여러건 들을 수 있고 강의도 여러명의 학생을 포함할 수 있음
- 배우 <-> 영화
- 상품 <-> 주문
  - 하나의 상품은 여러 주문에 포함될 수 있음
  - 하나의 주문에는 여러 상품이 포함될 수 있음

## 4.1.7 키

릴레이션(테이블)에서 튜플(행)을 유일하게 식별하거나 구별하는 데 사용되는 속성(컬럼) 또는 속성들의 집합

### 슈퍼키

행을 유일하게 식별할 수 있는 속성 집합 (유일성)

- {학번}
- {학번,이름}
- {학번,이름,나이}

### 후보키

슈퍼키중에 최소성을 만족하는 키

- {학번}

### 기본키

PK라고도 불리며 후보키중 기본적으로 사용하기로 선택된 키
테이블당 하나만 존재하며 유일성과 최소성을 만족함
**자연키** : 엔터티의 속성으로 활용한 기본키
**인조키** : 의미가 없이 인위적으로 부여한 키 (주로 사용: 값이 잘 변하지 않기 때문)

### 대체키

기본키로 선택되지 않은 나머지 후보키들

### 외래키

다를 릴레이션의 기본키를 참조하는 속성

- NULL, 중복 허용
- 참조 무결성 유지

---

## 4.2 ERD와 정규화 과정

ERD는 패스

### 정규화

관계형 데이터베이스에서 **데이터의 중복을 줄이고 데이터 무결성을 향상시키기 위해 테이블을 분해하는 과정**

### 목적

- **데이터 중복 최소화**
- **데이터 일관성 유지**
- **저장 공간 효율화**
- **데이터 무결성 보장**

## 4.2.3 정규화 과정

### 제1정규화 : 모든 속성 값이 원자값을 가져야함

릴레이션의 모든 도메인이 원자 값을 같도록 구성하는 과정

### 제2정규화 : 1정규화를 만족하면서 부분 함수 종속을 제거한 형태

부분함수 종속 제거 -> 기본기카 복합키 일때, 기본키의 일부만으로 다른 속성이 결정되면 안된다
책에서 유저번호가 유저ID를 결정하고 유저ID와 수강명이 성취도를 결정하므로 분리해야 함

### 제3정규화 : 2정규화를 만족하면서 이행적 함수 종속을 만족하지 않는 상태

A->B->C 일경우 C는 A에 이행적으로 함수 종속되어 있다
책에서 유저 ID가 등급을 결정, 등급이 할인률을 결정하므로 각각 분리해야함

### BCNF 정규화 : 3정규화를 만족하면서 모든 결정자가 후보키인 형태

어떤 속성이든 다른 속성을 결정하려면 반드시 후보키(유일성, 최소성)이어야함
책에서 강사가 결정자이지만 후보키가 아님 -> 분리가 필요

---

## 4.3.1 트랜잭션

데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
ACID 특징을 가진다

### Atomicity(원자성)

"All or Nothing" - 모두 성공하거나 모두 실패

### Consistency(일관성)

**데이터베이스의 무결성 제약조건을 항상 만족해야 함**
잔고가 마이너스가 된다던가 하는 일은 없어야함 (마통은?)

### Isolation(고립/격리성)

동시에 실행되는 트랜잭션들이 서로 영향을 주지 않아야 함
복수의 병렬 트랜잭션에서 여러개의 격리 수준을 나누어서 동작함
수준이 낮을 수록 동시성이 높고 격리성은 떨어진다

### 격리수준

**READ UNCOMMITTED** (Level 0)

- 가장 낮은 격리 수준
- 하나의 트랜잭션이 커밋되기 전에 다른 트랜잭션에 노출됨
- 더티, 비반복, 팬텀 리드 모두 발생 가능
  **READ COMMITTED** (Level 1)
- 커밋된 데이터만 읽기(가장 많이 사용)
- 다른 트랜잭션에서 수정이 여전히 가능함
- 비반복 리드, 팬텀 리드 발생 가능
  **REPEATABLE READ** (Level 2)
- 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정 불가
- 새로운 행 추가는 막지않음
- 팬덤 리드 발생 가능
  **SERIALZABLE** (Level 3)
- 여러 트랜잭션이 동시에 같은 행에 접근 불가
- 성능이 가장 좋지 않으며 교착 상태 발생 가능성

### Durability(지속성)

성공적으로 완료된 트랜잭션의 결과는 영구적으로 저장

## 4.3.2. 무결성

- 개체 무결성 : 기본키로 선택된 필드는 빈값을 허용하지 않음
- 참조 무결성 : 서로 참조 관계에 있는 두 테이블의 데이터는 일관성을 유지해야함
- 고유 무결성 : 특정 속성에 유니크 값이 지정된 경우 그 속성 값은 모두 고유한 값을 가진다
- NULL 무결성 : 특정 속성 값이 NOT NULL 이면 NULL이 들어오면 안됨
