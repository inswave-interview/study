# 3장. 운영체제

## 3.1 운영체제와 컴퓨터

### 3.1.1 운영체제의 역할과 구조

- **운영체제(OS) 정의**  
  사용자와 하드웨어 사이의 *중간 관리자* 역할을 수행하는 시스템 소프트웨어.  
  하드웨어 자원의 효율적 관리, 사용자 편의 지원, 보호 기능 제공.

- **운영체제 주요 역할**  
  - **프로세스 관리:** 프로세스 스케줄링, 생성/종료, 동기화, 문맥교환  
  - **메모리 관리:** 물리/가상 메모리 관리, 페이징/세그먼테이션, 단편화 해결  
  - **파일 시스템 관리:** 파일 생성, 삭제, 권한 관리, 저장장치 관리  
  - **입출력 시스템 관리:** 디바이스 드라이버 통해 하드웨어와 통신, 버퍼링, 캐싱  
  - **시스템 보호:** 유저 모드/커널 모드 분리, 권한 관리, 시스템콜 인터페이스  
  - **인터페이스(쉘):** 사용자 명령어 입력 처리, GUI/CLI 제공

- **운영체제 구성 요소**  
  - **커널 (Kernel):** 핵심 제어부, 직접 하드웨어와 상호작용하며 자원관리  
  - **시스템 콜 (System Call):** 사용자 프로세스가 커널 기능을 요청하는 인터페이스  
  - **드라이버 (Device Driver):** 특정 하드웨어 제어용 소프트웨어  
  - **인터페이스(쉘, GUI):** 사용자와 OS 사이의 명령 전달 및 결과 표시

- **커널 모드 vs 유저 모드**  
  - 유저 모드: 제한된 명령만 실행 가능, 직접 하드웨어 접근 불가  
  - 커널 모드: OS가 동작하는 특권 모드, 모든 명령 실행 가능

- **시스템콜의 동작 예시**  
  - 읽기/쓰기: `read()`, `write()`  
  - 프로세스 생성: `fork()`, `exec()`  
  - 프로세스 종료: `exit()`

***

### 3.1.2 컴퓨터의 요소

- **컴퓨터 하드웨어 구성요소**  
  - **CPU (Central Processing Unit):** 산술논리연산장치(ALU), 제어장치(CU), 레지스터 포함  
  - **메모리:** 주기억장치(RAM), 캐시(L1, L2, L3), 레지스터  
    - 레지스터: CPU 내부의 초고속 임시 기억장치  
    - 캐시: CPU와 RAM 사이 속도 차이 완화  
  - **보조기억장치:** HDD, SSD 등 비휘발성 저장  
  - **입출력장치:** 키보드, 마우스, 모니터, 네트워크 등  
  - **버스:** 데이터, 주소, 제어 버스 등 컴포넌트 간 데이터 전송 경로

- **컴퓨터의 소프트웨어 구성요소**  
  - 운영체제(OS) 및 응용 프로그램 등

- **실제 동작 흐름 사례**  
  사용자가 문서 작성 시 저장 → OS가 파일시스템 통해 디스크에 파일 기록 → CPU가 명령어 처리 → RAM에서 데이터와 명령어 불러옴

***

## 3.2 메모리

### 3.2.1 메모리 계층

| 계층      | 예시      | 속도          | 용량          | 특징 및 역할                                |
|---------|----------|-------------|-------------|------------------------------------------|
| 레지스터   | CPU 내부 레지스터 | 최고 속도     | 매우 작음       | CPU가 직접 산술/논리 연산에 즉시 사용          |
| 캐시      | L1, L2, L3 캐시 | 매우 빠름     | 작음         | 로컬리티 원리에 근거해 자주 쓰이는 데이터 저장  |
| RAM(주기억장치) | DRAM        | 빠름        | 중간        | 실행 중인 프로그램과 데이터 저장               |
| 보조기억장치  | SSD, HDD   | 느림        | 매우 큼       | 영구 저장, 가상메모리 스왑 영역 활용             |

- **로컬리티 원리(Locality of Reference)**  
  - 시간적 지역성: 최근 사용한 데이터/명령은 다시 사용될 가능성 높음  
  - 공간적 지역성: 인접 메모리 주소도 사용할 가능성 높음

### 3.2.2 메모리 관리

- **연속 할당 방식**  
  - 단순하지만, 외부 단편화 문제로 메모리 낭비 발생

- **비연속 할당 방식**  
  - **페이징 (Paging):** 고정 크기 페이지로 메모리 분할  
    - 페이지 테이블로 가상 주소를 물리 주소로 변환  
  - **세그먼테이션 (Segmentation):** 가변 크기 논리 단위 분할(코드, 데이터 등)

- **가상 메모리**  
  - 실제 메모리 용량보다 큰 주소 공간 제공  
  - 스와핑(swapping)으로 사용하지 않는 페이지를 디스크로 이동

- **페이지 교체 알고리즘**  
  - FIFO (First In First Out): 먼저 들어온 페이지 교체  
  - LRU (Least Recently Used): 가장 오래 사용하지 않은 페이지 교체  
  - LFU (Least Frequently Used): 가장 적게 사용한 페이지 교체

***

## 3.3 프로세스와 스레드

### 3.3.1 프로세스와 컴파일 과정

- **프로세스**  
  - 실행 중인 프로그램, 메모리와 CPU 자원 독립적으로 할당  
  - 운영체제가 관리하는 기본 실행 단위

- **컴파일 과정 예시**  
  1. 소스코드 작성 (`hello.c`)  
  2. 전처리 (매크로 확장 등)  
  3. 컴파일 (오브젝트 파일 `.o` 생성)  
  4. 링킹 (라이브러리 함수 결합)  
  5. 로딩 (실행 파일 메모리에 적재)  
  6. 실행 (프로세스 생성 및 실행 시작)

```bash
gcc hello.c -o hello
./hello
```

***

### 3.3.2 프로세스의 상태

| 상태        | 설명                                       |
|------------|------------------------------------------|
| 생성(New)  | 프로세스 생성 중                              |
| 준비(Ready) | CPU 할당 대기, 준비 완료                        |
| 실행(Running)| CPU에서 실행 중                              |
| 대기(Waiting/Blocked) | 입출력 등 이벤트 대기 중                      |
| 종료(Terminated) | 실행 완료 및 종료                             |

- **상태 전이 예시**  
  - Ready → Running: CPU 할당  
  - Running → Waiting: I/O 요청 등으로 대기  
  - Waiting → Ready: 이벤트 완료 후 준비 상태로 복귀

***

### 3.3.3 프로세스의 메모리 구조

| 영역   | 역할 및 내용                                      |
|-------|-------------------------------------------------|
| 코드   | 프로그램 실행 명령어 저장 (읽기 전용)                   |
| 데이터  | 전역 변수, 정적 변수 저장                              |
| 힙     | 동적 메모리 할당 영역 (malloc, new 등)                  |
| 스택    | 함수 호출 시 지역 변수, 매개변수, 리턴 주소 저장             |

***

### 3.3.4 PCB (Process Control Block)

- **PCB 정의**  
  프로세스 상태와 실행에 필요한 모든 정보를 담은 자료구조

- **포함 정보**  
  - 프로세스 ID (PID)  
  - 프로세스 상태  
  - 프로그램 카운터 (다음 실행 명령 주소)  
  - CPU 레지스터 값  
  - 메모리 관리 정보 (페이지 테이블 등)  
  - 입출력 상태 정보 및 파일 디스크립터

- **실무 예시**  
  OS가 문맥교환 시 PCB 내용을 저장 및 복원하여 CPU 작업 전환

***

### 3.3.5 멀티프로세싱

- **정의:**  
  두 개 이상의 CPU나 코어에서 여러 프로세스를 병렬 실행하는 환경

- **예시:**  
  서버 환경에서 여러 클라이언트 요청을 각각 다른 CPU가 처리

***

### 3.3.6 스레드와 멀티스레딩

- **스레드**  
  프로세스 내 실행의 최소 단위, 코드와 데이터는 공유, 스택은 별도 유지

- **멀티스레딩 예시**  
  웹 서버에서 UI 처리 스레드와 데이터 처리 스레드가 함께 동작

- **프로그래밍 예시**  
  ```java
  new Thread(() -> {
      System.out.println("스레드 실행");
  }).start();
  ```

***

### 3.3.7 공유 자원과 임계 영역

- **임계 영역**  
  여러 스레드가 동시에 접근 시 데이터 일관성 위험 구간

- **동기화 기법**  
  - Mutex (상호배제 락)  
  - Semaphore (신호등 개념으로 자원 개수 관리)  
  - Monitor (객체 단위 락 관리)

- **실제 문제 예시**  
  은행 계좌 잔액 동시 수정 시 동기화 없으면 오류 발생 가능

***

### 3.3.8 교착 상태 (Deadlock)

- **Deadlock 정의**  
  둘 이상의 프로세스가 서로 자원을 점유한 채 상대의 자원을 기다리며 무한 대기 상태에 빠짐

- **발생 4가지 조건**  
  1. 상호 배제 (Mutual Exclusion)  
  2. 점유와 대기 (Hold and Wait)  
  3. 비선점 (No Preemption)  
  4. 환형 대기 (Circular Wait)

- **해결 방법**  
  - 예방: 조건 중 하나 미성립하도록 설계  
  - 회피: 은행가 알고리즘으로 안전 상태 유지  
  - 발견 및 회복: Deadlock 탐지 후 프로세스 종료 또는 자원 강제 선점

***

## 3.4 CPU 스케줄링 알고리즘

### 3.4.1 비선점형 방식

- **FCFS (First Come First Served)**  
  - 먼저 요청된 프로세스부터 CPU 할당  
  - 간단하지만 Convoy Effect 문제 발생 가능

- **SJF (Shortest Job First)**  
  - 예상 실행 시간 가장 짧은 프로세스 우선  
  - 최적 평균 대기시간 보장, Starvation 발생 가능성 있음

### 3.4.2 선점형 방식

- **Round Robin**  
  - 일정 시간(Time Quantum)마다 프로세스 교체  
  - 시간 분할 시스템에 적합, 공정성 높음

- **SRTF (Shortest Remaining Time First)**  
  - 남은 실행 시간이 가장 짧은 프로세스에 CPU 할당  
  - SJF의 선점형 버전, 자주 선점되어 Starvation 발생 가능

***

# 4장. 데이터베이스

## 4.1 데이터베이스의 기본

### 4.1.1 엔터티

- 독립적으로 존재하는 객체나 개념 (예: 학생, 상품, 주문)

### 4.1.2 릴레이션

- 속성(Attribute)들의 집합으로 구성된 테이블, 엔터티를 표현

### 4.1.3 속성

- 엔터티가 가지는 특성 (예: 이름, 학번, 가격)

### 4.1.4 도메인

- 속성 값의 정의된 유효 범위 (예: 숫자 범위, 문자 길이 제한)

### 4.1.5 필드와 레코드

- 필드: 테이블 내 한 데이터 항목(열)  
- 레코드(튜플): 필드들의 집합, 행 단위 데이터

### 4.1.6 관계

- 엔터티들 사이의 연결  
  - 1:1, 1:N, N:M 등

### 4.1.7 키

- **슈퍼키:** 유일한 식별자 속성 집합  
- **후보키:** 최소 유일 식별자, 슈퍼키 중 최소 집합  
- **기본키(Primary Key):** 후보키 중 대표 키, 중복·NULL 불가  
- **대체키:** 후보키 중 기본키로 지정되지 않은 키  
- **외래키(Foreign Key):** 다른 테이블의 기본키 참조

***

## 4.2 ERD와 정규화 과정

### 4.2.1 ERD의 중요성

- 데이터 모델 시각화 및 관계 설계를 위한 핵심 도구

### 4.2.2 예제로 배우는 ERD

- 예) 학생-수강-과목 구조  
  학생(N) ↔ 수강(N) ↔ 과목(N) = N:M 관계, 중간 엔터티 ‘수강’으로 분해

### 4.2.3 정규화 과정

| 단계      | 특징                                           |
|----------|----------------------------------------------|
| 1정규형(1NF) | 원자값만 허용, 반복 그룹 제거                          |
| 2정규형(2NF) | 기본키 일부에 종속된 속성 제거(부분 함수 종속 해소)            |
| 3정규형(3NF) | 비키 속성이 다른 비키 속성에 종속되는 이행적 함수 종속 제거         |
| BCNF       | 모든 결정자가 후보키여야 함                           |

***

## 4.3 트랜잭션과 무결성

### 4.3.1 트랜잭션

- 데이터베이스 상태 변경의 최소 논리 단위  
- **ACID 원칙:**  
  - 원자성(Atomicity): 전부 실행하거나 전부 실행하지 않음  
  - 일관성(Consistency): 상태 변화가 항상 규칙에 부합  
  - 격리성(Isolation): 병행 수행 중에도 결과 일관성 유지  
  - 지속성(Durability): 성공 후 데이터 영구 저장

### 4.3.2 무결성

- 데이터 정확성 유지 위한 제약 조건  
- 개체 무결성(기본키 제한), 참조 무결성(외래키 관계), 도메인 무결성(타입/범위 제한)

***

## 4.4 데이터베이스의 종류

### 4.4.1 관계형 데이터베이스

- 테이블 기반 데이터 표현, 명확한 스키마  
- SQL 언어 사용 (Oracle, MySQL, PostgreSQL 등)

### 4.4.2 NoSQL 데이터베이스

- 비관계형, 자율 스키마, 대규모 데이터, 고속 처리 (MongoDB, Cassandra 등)

***

## 4.5 인덱스

### 4.5.1 인덱스의 필요성

- 데이터 검색 속도 극대화 목적

### 4.5.2 B-트리

- 균형 이진트리로 삽입, 삭제, 탐색 효율적

### 4.5.3 인덱스 만드는 방법

- SQL 구문: `CREATE INDEX idx_name ON table(column);`

### 4.5.4 인덱스 최적화 기법

- 자주 검색하는 컬럼에 인덱스 생성  
- 과도한 인덱스는 쓰기 성능 저하 유발  
- 클러스터드 인덱스, 커버링 인덱스 전략 활용

***

## 4.6 조인의 종류

| 조인 명칭  | 설명 및 특징                                                                 |
|-----------|-----------------------------------------------------------------------------|
| 내부 조인  | 두 테이블에서 조건에 일치하는 행만 반환 (가장 일반적)                            |
| 왼쪽 조인  | 왼쪽 테이블 모든 행 반환 + 오른쪽 매칭되는 행 또는 NULL                         |
| 오른쪽 조인| 오른쪽 테이블 모든 행 반환 + 왼쪽 매칭되는 행 또는 NULL                         |
| 합집합 조인| 두 테이블의 모든 행 반환, 일치하지 않는 행은 NULL로 표시 (Full Outer Join)        |

***

## 4.7 조인의 원리

### 4.7.1 중첩 루프 조인 (Nested Loop Join)

- 작은 테이블 각각의 행에 대해 상대 테이블 전체 탐색  
- 인덱스 없거나 소규모 테이블 적합

### 4.7.2 정렬 병합 조인 (Sort-Merge Join)

- 조인 대상 두 테이블을 조인키 기준으로 정렬 후 병합  
- 대형 테이블에 효율적

### 4.7.3 해시 조인 (Hash Join)

- 작은 테이블을 해시 테이블로 만들어 큰 테이블 행과 매칭  
- 대용량 비정형 데이터 처리에 효과적

***

출처
[1] 운영체제의 구성요소 - velog https://velog.io/@kang9366/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C
[2] [운영체제/컴퓨터 구조] 컴퓨터 하드웨어의 구성요소 - Study Repository https://rlaehddnd0422.tistory.com/154
[3] OS(운영체제)란 무엇일까? (역할, 구성요소, 위치) - hellouz's Devlog https://hellouz818.tistory.com/7
[4] 운영체제(OS)란? 개념과 구조(커널, 시스템콜 등) - 데분노트 https://coduking.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS%EB%9E%80-%EA%B0%9C%EB%85%90%EA%B3%BC-%EA%B5%AC%EC%A1%B0%EC%BB%A4%EB%84%90-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C-%EB%93%B1
[5] [Operating System - Chapter 1] 운영체제란 무엇인가? https://imbf.github.io/computer-science(cs)/2020/08/21/What-is-The-Operating-System.html
[6] 운영체제 - 나무위키 https://namu.wiki/w/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C
[7] [운영체제] Ch2. 운영체제 구조 - 개발냥발 - 티스토리 https://hyeo-noo.tistory.com/346
[8] 컴퓨터 구조와 운영체제 50분만에 핵심 개념 정복하기 (ft. 강민철 저자님) https://www.youtube.com/watch?v=LBqJwmFMQHI
[9] 운영체제 - 국민대학교 | KOCW 공개 강의 http://www.kocw.net/home/cview.do?mty=p&kemId=1218223
[10] 컴퓨터 구조와 운영체제 핵심 노트 - 예스24 https://www.yes24.com/product/goods/126715268

---

### 예상 면접 질문

1.  **프로세스와 스레드의 근본적인 차이점은 무엇이며, 어떤 경우에 멀티프로세스 대신 멀티스레드를 사용하는 것이 더 효율적인가요? 그 이유는 무엇입니까?**
    - *의도: 두 개념의 핵심 차이(메모리 공유)와 그로 인한 성능/자원 이점을 이해하는지 확인.*

2.  **사용자 프로그램이 파일을 읽거나 쓸 때, 운영체제 내부에서는 어떤 과정을 거치나요? 커널 모드, 유저 모드, 시스템 콜의 역할을 중심으로 설명해주세요.**
    - *의도: OS의 핵심 보호 메커니즘과 동작 원리를 실제 I/O 사례를 통해 설명할 수 있는지 확인.*

3.  **교착 상태(Deadlock)의 발생 조건 4가지를 설명하고, 이 중 하나의 조건을 의도적으로 위배하여 교착 상태를 '예방'하는 구체적인 방법의 예를 들어주세요.**
    - *의도: 발생 조건 암기를 넘어, 이를 해결하기 위한 실질적인 예방책과 연결하여 이해하는지 확인.*

4.  **가상 메모리는 실제 물리 메모리보다 큰 공간을 제공하는데, 이것이 어떻게 가능한지 '페이징'과 '스와핑' 개념을 사용하여 설명해주세요.**
    - *의도: 가상 메모리의 핵심 동작 원리와 이를 뒷받침하는 메모리 관리 기법을 이해하는지 확인.*

5.  **데이터베이스에서 정규화를 하는 주된 이유는 무엇이며, 2정규형(2NF)과 3정규형(3NF)의 차이를 '함수적 종속성' 개념을 사용해 설명해주세요.**
    - *의도: 정규화의 목적(데이터 중복 최소화, 이상 현상 방지)과 각 단계의 핵심 원리를 정확히 이해하는지 확인.*

6.  **트랜잭션의 ACID 원칙 중 '격리성(Isolation)'이 왜 중요하며, 만약 격리성이 보장되지 않을 경우 어떤 문제가 발생할 수 있는지 구체적인 예를 들어 설명해주세요.**
    - *의도: 동시성 제어의 중요성과 격리 수준(Isolation Level)의 필요성을 실질적인 문제 상황과 연결하여 이해하는지 확인.*

7.  **데이터 검색 속도 향상을 위해 인덱스를 사용하지만, 인덱스를 무분별하게 추가하면 오히려 성능이 저하될 수 있습니다. 그 이유는 무엇인가요?**
    - *의도: 인덱스의 장점(읽기 성능)과 단점(쓰기 성능, 저장 공간)을 모두 이해하고 트레이드오프를 고려할 수 있는지 확인.*

8.  **CPU 스케줄링 알고리즘 중, 선점형 방식인 'Round Robin'과 비선점형 방식인 'SJF'의 장단점을 비교하고, 각각 어떤 종류의 시스템에 더 적합할지 설명해주세요.**
    - *의도: 스케줄링 방식의 차이를 이해하고, 각 알고리즘의 특성이 시스템 목표(응답 시간, 처리량 등)에 미치는 영향을 설명할 수 있는지 확인.*

9.  **프로세스의 메모리 구조에서 '스택(Stack)' 영역과 '힙(Heap)' 영역의 차이점은 무엇이며, 각각 어떤 데이터가 언제 저장되는지 설명해주세요.**
    - *의도: 메모리 영역의 역할과 데이터의 생명주기(Life Cycle)를 정확히 이해하고 있는지 확인.*

10. **RDBMS와 NoSQL 데이터베이스의 가장 큰 차이점은 무엇이며, 어떤 비즈니스 요구사항이나 데이터 특성에 따라 둘 중 하나를 선택하게 될지 각각의 시나리오를 제시해주세요.**
    - *의도: 두 데이터베이스 패러다임의 차이를 이해하고, 실제 상황에 맞는 기술 선택 능력을 갖추었는지 확인.*
