# 1주차 스터디 정리

## 범위

**1. 디자인 패턴**

- 1.1.1 싱글톤 팩턴
- 1.1.2 팩토리 패턴
- 1.1.3 전략 패턴
- 1.1.4 옵저버 패턴
- 1.1.5 프록시 패턴과 프록시 서버
- 1.1.6 이터레이터 패턴
- 1.1.7 노출모듈 패턴
- 1.1.8 MVC 패턴
- 1.1.9 MVP 패턴
- 1.1.10 MVVM 패턴

**2. 프로그래밍 패러다임**

- 1.2.1 선언형과 함수형 프로다이밍
- 1.2.2 객체지향 프로그래밍
- 1.2.3 절차형 프로그래밍
- 1.2.4 패러다임의 혼합

**3. 네트워크 기초**

- 2.1.1 처리량과 지연 시간
- 2.1.2 네트워크 토폴로지와 병목 현상
- 2.1.3 네트워크 분류
- 2.1.4 네트워크 성능 분석 명령어
- 2.1.5 네트워크 프로토콜 표준화

**4. TCP/IP 4계층 모델**

**5. 네트워크 기기**

**6. IP주소**

**7. HTTP**

## 발표자

- 디자인 패턴, 프로그래밍 패러다임 : 김성민
- 네트워크 : 김시연

## 진행 날짜

- 2025년 8월 8일

## 예상 질문 내용 및 답변 (1팀)

### 질문 1. 주소창에 www.naver.com을 쳤을 때 동작하는 일

#### 1. 리다이렉트 확인

- 브라우저가 HSTS(HTTP Strict Transport Security) 정책이나 내부 리다이렉트 규칙이 있는지 확인
- 예를 들어 HTTP로 접속 시 HTTPS로 자동 리다이렉트하는 규칙이 있으면 해당 URL로 이동
- 리다이렉트 규칙이 없으면 다음 과정 진행

#### 2. 캐싱 확인

- **브라우저가 요청이 캐싱 가능한지 파악**

  - Cache-Control, Expires 헤더를 통해 캐시 정책 확인
  - 캐시가 유효하면 서버 요청 없이 바로 응답 반환

- **브라우저 캐시**:

  - 메모리 캐시(RAM)에서 먼저 확인
  - 디스크 캐시에서 HTML, CSS, JS, 이미지 등 정적 리소스 확인
  - 캐시된 페이지가 있고 유효하면 바로 렌더링

- **공유 캐시**:
  - CDN(Content Delivery Network)이나 리버스 프록시 서버의 캐시 확인
  - Cloudflare, AWS CloudFront 같은 서비스에서 캐시된 정적 파일 제공
  - 지리적으로 가까운 엣지 서버에서 빠른 응답 제공

#### 3. DNS 조회

- **DNS 캐싱 확인**:
  - 브라우저 DNS 캐시 → OS DNS 캐시 → 라우터 DNS 캐시 순서로 확인
  - 각 단계에서 TTL(Time To Live) 값을 확인하여 캐시 유효성 판단
- **DNS 조회 과정**:
  - 로컬 DNS 서버(ISP 제공)에 재귀적 질의 요청
  - 루트 네임서버 → TLD 네임서버(.com) → 권한 있는 네임서버(naver.com) 순서로 조회
  - 최종적으로 www.naver.com에 해당하는 IP 주소(예: 223.130.200.107) 반환

#### 4. IP 라우팅

- **라우팅 테이블 확인**:
  - 로컬 라우팅 테이블에서 목적지 IP까지의 경로 결정
  - 기본 게이트웨이를 통해 인터넷으로 패킷 전송
- **ARP(Address Resolution Protocol) 과정**:
  - IP 주소를 MAC 주소로 변환하는 과정
  - 같은 네트워크 내에서는 직접 통신, 다른 네트워크는 라우터의 MAC 주소 사용
  - 물리적 네트워크에서 실제 하드웨어 장비까지 패킷 전달

#### 5. TCP 연결

- **3-way handshake 과정**:

  - **SYN**: 클라이언트가 임의의 시퀀스 번호(ISN)와 함께 연결 요청
  - **SYN+ACK**: 서버가 클라이언트의 시퀀스 번호+1을 ACK로, 자신의 시퀀스 번호를 SYN으로 응답
  - **ACK**: 클라이언트가 서버의 시퀀스 번호+1을 ACK로 전송하여 연결 완료

- **SSL/TLS 핸드셰이크** (HTTPS인 경우):
  - 클라이언트가 지원하는 암호화 방식 제안
  - 서버가 SSL 인증서와 공개키 전송
  - 대칭키 생성 및 교환으로 보안 연결 설정

#### 6. 컨텐츠 다운로드

- **HTTP 요청 전송**:
  - GET / HTTP/1.1 요청 헤더 전송
  - User-Agent, Accept, Cookie 등 메타데이터 포함
- **서버 응답 처리**:

  - 상태 코드(200 OK, 301 Redirect 등) 확인
  - 응답 헤더(Content-Type, Content-Length, Set-Cookie 등) 파싱
  - HTML 본문 데이터 수신

- **TTFB(Time To First Byte)**:
  - DNS 조회부터 첫 번째 바이트 수신까지의 시간
  - 네트워크 지연시간과 서버 처리 시간의 합
  - 웹 성능 측정의 중요한 지표

#### 7. 브라우저 렌더링

- **HTML 파싱**:

  - DOM(Document Object Model) 트리 생성
  - 태그를 노드로 변환하여 계층 구조 구성

- **CSS 처리**:

  - CSSOM(CSS Object Model) 트리 생성
  - 스타일 규칙을 파싱하여 렌더 트리 구성

- **JavaScript 실행**:

  - JavaScript 엔진(V8, SpiderMonkey 등)에서 스크립트 실행
  - DOM 조작, 이벤트 리스너 등록, AJAX 요청 등 동적 처리

- **렌더링 과정**:
  - Layout(Reflow): 요소의 위치와 크기 계산
  - Paint: 픽셀 단위로 화면에 그리기
  - Composite: 레이어 합성하여 최종 화면 완성

---


### 질문 2. 프록시 패턴이란 무엇이고 이것으로 CORS 문제를 해결하는 방법

#### 프록시 패턴 (Proxy Pattern)

- **구조 패턴의 하나**로, 실제 객체에 대한 접근을 제어하기 위해 대리자(Proxy)를 두는 패턴
- 클라이언트와 실제 서비스 객체 사이에 중간층을 만들어 요청을 가로채고 제어
- **GoF 디자인 패턴** 중 하나로 객체지향 설계에서 널리 사용됨

#### 프록시 패턴의 종류와 용도

- **가상 프록시(Virtual Proxy)**:

  - 무거운 객체의 생성을 지연시켜 메모리 효율성 증대
  - 예: 큰 이미지 파일을 실제로 필요할 때까지 로딩 지연

- **보호 프록시(Protection Proxy)**:

  - 접근 권한을 제어하여 보안 강화
  - 예: 사용자 권한에 따른 메서드 접근 제한

- **원격 프록시(Remote Proxy)**:

  - 원격 객체에 대한 로컬 대표자 역할
  - 예: RPC(Remote Procedure Call), RESTful API 클라이언트

- **캐싱 프록시(Caching Proxy)**:
  - 요청 결과를 캐시하여 성능 향상
  - 예: Redis, Memcached를 통한 데이터 캐싱

#### CORS (Cross-Origin Resource Sharing) 문제

- **SOP(Same-Origin Policy) 위반**:

  - 브라우저의 기본 보안 정책으로 다른 출처(Origin)의 리소스 접근 제한
  - Origin = 프로토콜 + 도메인 + 포트 (예: https://example.com:443)

- **CORS 에러 발생 상황**:

  - 프론트엔드: `http://localhost:3000`
  - 백엔드 API: `https://api.example.com`
  - 브라우저가 "다른 출처"로 판단하여 요청 차단

- **Preflight 요청**:
  - 복잡한 HTTP 요청(PUT, DELETE, 커스텀 헤더 등) 전에 OPTIONS 요청 먼저 전송
  - 서버가 해당 요청을 허용하는지 사전 확인

#### 프록시로 CORS 해결 방법

#### 프록시 동작 원리

1. **클라이언트 요청**: `http://localhost:3000/api/users`
2. **프록시 서버 수신**: 같은 도메인(localhost:3000)으로 인식하여 CORS 제한 없음
3. **실제 API 호출**: 프록시 서버가 `https://api.example.com/users`로 요청 전달
4. **응답 중계**: API 응답을 클라이언트로 그대로 전달
5. **브라우저 수신**: 같은 도메인에서 온 응답으로 인식하여 정상 처리

#### 실제 도구와 서비스

- **개발 도구**: webpack dev server, Vite, Create React App proxy
- **웹 서버**: Nginx, Apache HTTP Server
- **클라우드 서비스**: Cloudflare, AWS CloudFront, Azure Front Door
- **API 게이트웨이**: Kong, Zuul, AWS API Gateway

---

### 질문 3. 쿠키와 세션의 차이

### 쿠키(Cookie) 상세 분석

**저장 방식과 구조**:

- **저장 위치**: 클라이언트 브라우저의 로컬 스토리지
- **저장 형태**: `name=value; expires=date; path=/; domain=.example.com; secure; httponly` 형태의 텍스트 문자열
- **용량 제한**: 개별 쿠키당 4KB, 도메인당 최대 50개 (브라우저마다 다름)
- **지속성**: 만료 시간을 설정하여 브라우저 종료 후에도 유지 가능

**쿠키의 속성들**:

- **Expires/Max-Age**: 만료 시간 설정 (없으면 세션 쿠키로 동작)
- **Domain**: 쿠키가 전송될 도메인 범위 (.example.com이면 서브도메인 포함)
- **Path**: 쿠키가 전송될 URL 경로 범위 (/admin이면 해당 경로 하위만)
- **Secure**: HTTPS 연결에서만 전송
- **HttpOnly**: JavaScript에서 접근 불가 (XSS 공격 방지)
- **SameSite**: CSRF 공격 방지를 위한 동일 사이트 정책 (Strict, Lax, None)

**쿠키 전송 과정**:

1. 서버가 `Set-Cookie` 헤더로 쿠키 설정
2. 브라우저가 쿠키를 로컬에 저장
3. 이후 해당 도메인 요청 시 `Cookie` 헤더에 자동 포함하여 전송
4. 서버가 쿠키 값을 읽어 사용자 식별 및 상태 관리

### 세션(Session) 상세 분석

**저장 방식과 구조**:

- **저장 위치**: 서버의 메모리, 파일 시스템, 또는 데이터베이스
- **저장 형태**: 서버 측 자료구조 (HashMap, Redis 등)에 세션 ID를 키로 하는 데이터
- **용량 제한**: 서버 리소스에 따라 결정 (메모리, 디스크 용량)
- **지속성**: 서버 재시작 시 메모리 세션은 소멸 (영구 저장소 사용 시 유지 가능)

**세션 동작 방식**:

1. **세션 생성**: 사용자 첫 방문 시 서버가 고유한 세션 ID 생성 (UUID 등 사용)
2. **세션 ID 전송**: `Set-Cookie: JSESSIONID=ABC123` 형태로 클라이언트에 전송
3. **세션 데이터 저장**: 서버 메모리나 세션 저장소에 사용자 정보 저장
4. **세션 식별**: 이후 요청에서 세션 ID 쿠키를 통해 해당 세션 데이터 조회
5. **세션 만료**: 타임아웃이나 로그아웃 시 세션 데이터 삭제

**세션 저장소 종류**:

- **메모리 세션**: 서버 RAM에 저장 (빠르지만 서버 재시작 시 소멸)
- **파일 세션**: 디스크 파일에 저장 (영구성 있지만 I/O 부하)
- **데이터베이스 세션**: MySQL, PostgreSQL 등에 저장 (영구성, 확장성)
- **분산 세션**: Redis, Memcached 등 인메모리 DB 사용 (고성능, 분산 환경)

### 보안 측면 비교

**쿠키 보안 이슈**:

- **XSS(Cross-Site Scripting)**: JavaScript로 쿠키 탈취 가능
  - 해결책: HttpOnly 속성 사용
- **CSRF(Cross-Site Request Forgery)**: 다른 사이트에서 쿠키 자동 전송
  - 해결책: SameSite 속성, CSRF 토큰 사용
- **중간자 공격**: HTTP 통신에서 쿠키 가로채기
  - 해결책: Secure 속성으로 HTTPS만 허용

**세션 보안 이슈**:

- **세션 하이재킹**: 세션 ID 탈취로 사용자 계정 접근
  - 해결책: HTTPS 사용, 세션 ID 재생성, IP 검증
- **세션 고정 공격**: 공격자가 미리 알고 있는 세션 ID 사용하도록 유도
  - 해결책: 로그인 시 새로운 세션 ID 생성
- **세션 타임아웃**: 장시간 비활성 상태에서도 세션 유지
  - 해결책: 적절한 타임아웃 설정, 슬라이딩 세션

### 실제 사용 사례와 선택 기준

**쿠키 사용 사례**:

- **자동 로그인**: 암호화된 사용자 식별 토큰 저장
- **사용자 설정**: 언어, 테마, 지역 설정 등 개인화 정보
- **장바구니**: 비회원 상태에서도 상품 정보 유지
- **추천 시스템**: 사용자 행동 패턴 분석을 위한 데이터 수집
- **광고 타겟팅**: 사용자 관심사 및 방문 이력 추적

**세션 사용 사례**:

- **로그인 상태 관리**: 인증된 사용자의 권한 정보 저장
- **임시 데이터**: 다단계 폼 작성 중간 데이터 보관
- **토큰 저장**: JWT 리프레시 토큰, CSRF 토큰 등 보안 토큰
- **게임 상태**: 실시간 게임에서 사용자 진행 상황
- **거래 정보**: 결제 과정 중 민감한 정보 임시 저장

---

## 예상 질문 내용 및 답변 (2팀)

1. 싱글톤 패턴에 대해 설명하고, 활용사례에 대해 말해주세요
   -> 싱글톤 패턴은 하나의 클래스에 오직 하나의 인스턴스를 가지는 패턴을 말합니다. 활용사례로는 mongoose 모듈이 있습니다. 데이터 베이스를 연결할 때 사용하는 connect() 함수는 싱글톤 인스턴스를 반환합니다.

2. 오버로딩과 오버라이딩의 차이점을 설명해주세요
   -> 오버로딩은 같은 이름을 가진 메서드를 메서드의 타입 매겨변수의 유형, 개수 등에 따라 여러개 두는 것을 말합니다. 오버라이딩은 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것을 말합니다.

3. MVC 패턴을 설명하고 MVVM 패턴과의 차이는 무엇인지 설명해보세요
   -> MVC 패턴은 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴입니다. 앱의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있다는 점과 재사용성과 확장성이 용이하다는 장점이 있고, 애플리케이션이 복잡해질수록 모델과 뷰의 관계 또한 복잡해지는 단점이 있습니다.
   MVVM 패턴은 MVC의 C에 해당하는 컨트롤러가 뷰모델(view model)로 바뀐 패턴입니다. 여기서 뷰모델은 뷰를 더 추상화한 계층이며, MVVM 패턴은 MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징입니다. 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있습니다.

4. OSI 7계층과 TCP/IP 4계층의 차이점은 무엇인가요?
   TCP/IP 계층과 달리 OSI 계층은 애플리케이션 계층을 세 개로 쪼개고 링크 계층을 데이터 링크 계층, 물리 계층으로 나눠서 설명하는 것이 다르며, 인터넷 계층을 네트워크 계층으로 부른다는 점이 다릅니다.

5. TCP와 UDP의 차이점을 설명해주세요.
   TCP는 연결 지향 프로토콜로 3-way handshake를 통해 연결을 설정하고, 데이터 전송 순서를 보장하며 신뢰성을 제공합니다. 반면 UDP는 비연결 지향 프로토콜로 빠른 전송이 가능하지만 순서나 신뢰성을 보장하지 않습니다. TCP는 웹 브라우징, 이메일 등에 사용되고, UDP는 실시간 스트리밍, 게임 등에 사용됩니다.

6. 싱글톤 패턴의 단점과 해당 단점을 해결할 수 있는 방법은 무엇인가요?
   싱글톤 패턴의 단점은 의존성이 강해진다는 것입니다. 이를 해결하기 위한 방법으로는 의존성 주입이 있습니다.

7. 의존성 주입이란 무엇인가요?
   객체 지향 프로그래밍에서 의존하는 객체를 직접 생성하거나 관리하지 않고 외부에서 주입받는 것을 의미합니다.

8. CDN의 개념은 무엇인가요?
   CDN은 콘텐츠를 사용자와 가까운 지역의 서버에 캐싱하여 빠르게 전달하는 네트워크입니다. 주요 이점으로는 응답 속도 향상, 서버 부하 분산, 네트워크 대역폭 절약이 있습니다.

9. HTTP/1.x와 HTTP/2의 차이점은 무엇인가요?
   HTTP/1.x는 한번에 하나의 요청만 처리할 수 있어 HOL 블로킹 문제가 발생합니다. 또한 무거운 헤더 구조라는 단점도 존재합니다. 이에 반하여 HTTP/2는 멀티플렉싱을 지원하여 하나의 연결로 여러 요청을 동시에 처리할 수 있고, 헤더 압축으로 오버헤드를 줄였습니다. 또한 서버 푸시 기능으로 클라이언트 없이도 리소스를 미리 전송할 수 있어 성능이 향상되었습니다.

10. ARP란 무엇인가요?
    IP 주소를 MAC 주소로 변환하는 프로토콜입니다.

