# 1주차 스터디 정리

## 범위

**1. 디자인 패턴**

- 1.1.1 싱글톤 팩턴
- 1.1.2 팩토리 패턴
- 1.1.3 전략 패턴
- 1.1.4 옵저버 패턴
- 1.1.5 프록시 패턴과 프록시 서버
- 1.1.6 이터레이터 패턴
- 1.1.7 노출모듈 패턴
- 1.1.8 MVC 패턴
- 1.1.9 MVP 패턴
- 1.1.10 MVVM 패턴

**2. 프로그래밍 패러다임**

- 1.2.1 선언형과 함수형 프로다이밍
- 1.2.2 객체지향 프로그래밍
- 1.2.3 절차형 프로그래밍
- 1.2.4 패러다임의 혼합

**3. 네트워크 기초**

- 2.1.1 처리량과 지연 시간
- 2.1.2 네트워크 토폴로지와 병목 현상
- 2.1.3 네트워크 분류
- 2.1.4 네트워크 성능 분석 명령어
- 2.1.5 네트워크 프로토콜 표준화

**4. TCP/IP 4계층 모델**

**5. 네트워크 기기**

**6. IP주소**

**7. HTTP**

## 발표자

- 디자인 패턴, 프로그래밍 패러다임 : 김성민
- 네트워크 : 김시연

## 진행 날짜

- 2025년 8월 8일

## 예상 질문 내용 및 답변

### 질문 1. 주소창에 www.naver.com을 쳤을 때 동작하는 일

#### 1. 리다이렉트 확인

- 브라우저가 HSTS(HTTP Strict Transport Security) 정책이나 내부 리다이렉트 규칙이 있는지 확인
- 예를 들어 HTTP로 접속 시 HTTPS로 자동 리다이렉트하는 규칙이 있으면 해당 URL로 이동
- 리다이렉트 규칙이 없으면 다음 과정 진행

#### 2. 캐싱 확인

- **브라우저가 요청이 캐싱 가능한지 파악**

  - Cache-Control, Expires 헤더를 통해 캐시 정책 확인
  - 캐시가 유효하면 서버 요청 없이 바로 응답 반환

- **브라우저 캐시**:

  - 메모리 캐시(RAM)에서 먼저 확인
  - 디스크 캐시에서 HTML, CSS, JS, 이미지 등 정적 리소스 확인
  - 캐시된 페이지가 있고 유효하면 바로 렌더링

- **공유 캐시**:
  - CDN(Content Delivery Network)이나 리버스 프록시 서버의 캐시 확인
  - Cloudflare, AWS CloudFront 같은 서비스에서 캐시된 정적 파일 제공
  - 지리적으로 가까운 엣지 서버에서 빠른 응답 제공

#### 3. DNS 조회

- **DNS 캐싱 확인**:
  - 브라우저 DNS 캐시 → OS DNS 캐시 → 라우터 DNS 캐시 순서로 확인
  - 각 단계에서 TTL(Time To Live) 값을 확인하여 캐시 유효성 판단
- **DNS 조회 과정**:
  - 로컬 DNS 서버(ISP 제공)에 재귀적 질의 요청
  - 루트 네임서버 → TLD 네임서버(.com) → 권한 있는 네임서버(naver.com) 순서로 조회
  - 최종적으로 www.naver.com에 해당하는 IP 주소(예: 223.130.200.107) 반환

#### 4. IP 라우팅

- **라우팅 테이블 확인**:
  - 로컬 라우팅 테이블에서 목적지 IP까지의 경로 결정
  - 기본 게이트웨이를 통해 인터넷으로 패킷 전송
- **ARP(Address Resolution Protocol) 과정**:
  - IP 주소를 MAC 주소로 변환하는 과정
  - 같은 네트워크 내에서는 직접 통신, 다른 네트워크는 라우터의 MAC 주소 사용
  - 물리적 네트워크에서 실제 하드웨어 장비까지 패킷 전달

#### 5. TCP 연결

- **3-way handshake 과정**:

  - **SYN**: 클라이언트가 임의의 시퀀스 번호(ISN)와 함께 연결 요청
  - **SYN+ACK**: 서버가 클라이언트의 시퀀스 번호+1을 ACK로, 자신의 시퀀스 번호를 SYN으로 응답
  - **ACK**: 클라이언트가 서버의 시퀀스 번호+1을 ACK로 전송하여 연결 완료

- **SSL/TLS 핸드셰이크** (HTTPS인 경우):
  - 클라이언트가 지원하는 암호화 방식 제안
  - 서버가 SSL 인증서와 공개키 전송
  - 대칭키 생성 및 교환으로 보안 연결 설정

#### 6. 컨텐츠 다운로드

- **HTTP 요청 전송**:
  - GET / HTTP/1.1 요청 헤더 전송
  - User-Agent, Accept, Cookie 등 메타데이터 포함
- **서버 응답 처리**:

  - 상태 코드(200 OK, 301 Redirect 등) 확인
  - 응답 헤더(Content-Type, Content-Length, Set-Cookie 등) 파싱
  - HTML 본문 데이터 수신

- **TTFB(Time To First Byte)**:
  - DNS 조회부터 첫 번째 바이트 수신까지의 시간
  - 네트워크 지연시간과 서버 처리 시간의 합
  - 웹 성능 측정의 중요한 지표

#### 7. 브라우저 렌더링

- **HTML 파싱**:

  - DOM(Document Object Model) 트리 생성
  - 태그를 노드로 변환하여 계층 구조 구성

- **CSS 처리**:

  - CSSOM(CSS Object Model) 트리 생성
  - 스타일 규칙을 파싱하여 렌더 트리 구성

- **JavaScript 실행**:

  - JavaScript 엔진(V8, SpiderMonkey 등)에서 스크립트 실행
  - DOM 조작, 이벤트 리스너 등록, AJAX 요청 등 동적 처리

- **렌더링 과정**:
  - Layout(Reflow): 요소의 위치와 크기 계산
  - Paint: 픽셀 단위로 화면에 그리기
  - Composite: 레이어 합성하여 최종 화면 완성

---

## 질문 2. 프록시 패턴이란 무엇이고 이것으로 CORS 문제를 해결하는 방법

#### 프록시 패턴 (Proxy Pattern)

- **구조 패턴의 하나**로, 실제 객체에 대한 접근을 제어하기 위해 대리자(Proxy)를 두는 패턴
- 클라이언트와 실제 서비스 객체 사이에 중간층을 만들어 요청을 가로채고 제어
- **GoF 디자인 패턴** 중 하나로 객체지향 설계에서 널리 사용됨

#### 프록시 패턴의 종류와 용도

- **가상 프록시(Virtual Proxy)**:

  - 무거운 객체의 생성을 지연시켜 메모리 효율성 증대
  - 예: 큰 이미지 파일을 실제로 필요할 때까지 로딩 지연

- **보호 프록시(Protection Proxy)**:

  - 접근 권한을 제어하여 보안 강화
  - 예: 사용자 권한에 따른 메서드 접근 제한

- **원격 프록시(Remote Proxy)**:

  - 원격 객체에 대한 로컬 대표자 역할
  - 예: RPC(Remote Procedure Call), RESTful API 클라이언트

- **캐싱 프록시(Caching Proxy)**:
  - 요청 결과를 캐시하여 성능 향상
  - 예: Redis, Memcached를 통한 데이터 캐싱

#### CORS (Cross-Origin Resource Sharing) 문제

- **SOP(Same-Origin Policy) 위반**:

  - 브라우저의 기본 보안 정책으로 다른 출처(Origin)의 리소스 접근 제한
  - Origin = 프로토콜 + 도메인 + 포트 (예: https://example.com:443)

- **CORS 에러 발생 상황**:

  - 프론트엔드: `http://localhost:3000`
  - 백엔드 API: `https://api.example.com`
  - 브라우저가 "다른 출처"로 판단하여 요청 차단

- **Preflight 요청**:
  - 복잡한 HTTP 요청(PUT, DELETE, 커스텀 헤더 등) 전에 OPTIONS 요청 먼저 전송
  - 서버가 해당 요청을 허용하는지 사전 확인

#### 프록시로 CORS 해결 방법

#### 프록시 동작 원리

1. **클라이언트 요청**: `http://localhost:3000/api/users`
2. **프록시 서버 수신**: 같은 도메인(localhost:3000)으로 인식하여 CORS 제한 없음
3. **실제 API 호출**: 프록시 서버가 `https://api.example.com/users`로 요청 전달
4. **응답 중계**: API 응답을 클라이언트로 그대로 전달
5. **브라우저 수신**: 같은 도메인에서 온 응답으로 인식하여 정상 처리

#### 실제 도구와 서비스

- **개발 도구**: webpack dev server, Vite, Create React App proxy
- **웹 서버**: Nginx, Apache HTTP Server
- **클라우드 서비스**: Cloudflare, AWS CloudFront, Azure Front Door
- **API 게이트웨이**: Kong, Zuul, AWS API Gateway

---

## 질문 3. 쿠키와 세션의 차이

### 쿠키(Cookie) 상세 분석

**저장 방식과 구조**:

- **저장 위치**: 클라이언트 브라우저의 로컬 스토리지
- **저장 형태**: `name=value; expires=date; path=/; domain=.example.com; secure; httponly` 형태의 텍스트 문자열
- **용량 제한**: 개별 쿠키당 4KB, 도메인당 최대 50개 (브라우저마다 다름)
- **지속성**: 만료 시간을 설정하여 브라우저 종료 후에도 유지 가능

**쿠키의 속성들**:

- **Expires/Max-Age**: 만료 시간 설정 (없으면 세션 쿠키로 동작)
- **Domain**: 쿠키가 전송될 도메인 범위 (.example.com이면 서브도메인 포함)
- **Path**: 쿠키가 전송될 URL 경로 범위 (/admin이면 해당 경로 하위만)
- **Secure**: HTTPS 연결에서만 전송
- **HttpOnly**: JavaScript에서 접근 불가 (XSS 공격 방지)
- **SameSite**: CSRF 공격 방지를 위한 동일 사이트 정책 (Strict, Lax, None)

**쿠키 전송 과정**:

1. 서버가 `Set-Cookie` 헤더로 쿠키 설정
2. 브라우저가 쿠키를 로컬에 저장
3. 이후 해당 도메인 요청 시 `Cookie` 헤더에 자동 포함하여 전송
4. 서버가 쿠키 값을 읽어 사용자 식별 및 상태 관리

### 세션(Session) 상세 분석

**저장 방식과 구조**:

- **저장 위치**: 서버의 메모리, 파일 시스템, 또는 데이터베이스
- **저장 형태**: 서버 측 자료구조 (HashMap, Redis 등)에 세션 ID를 키로 하는 데이터
- **용량 제한**: 서버 리소스에 따라 결정 (메모리, 디스크 용량)
- **지속성**: 서버 재시작 시 메모리 세션은 소멸 (영구 저장소 사용 시 유지 가능)

**세션 동작 방식**:

1. **세션 생성**: 사용자 첫 방문 시 서버가 고유한 세션 ID 생성 (UUID 등 사용)
2. **세션 ID 전송**: `Set-Cookie: JSESSIONID=ABC123` 형태로 클라이언트에 전송
3. **세션 데이터 저장**: 서버 메모리나 세션 저장소에 사용자 정보 저장
4. **세션 식별**: 이후 요청에서 세션 ID 쿠키를 통해 해당 세션 데이터 조회
5. **세션 만료**: 타임아웃이나 로그아웃 시 세션 데이터 삭제

**세션 저장소 종류**:

- **메모리 세션**: 서버 RAM에 저장 (빠르지만 서버 재시작 시 소멸)
- **파일 세션**: 디스크 파일에 저장 (영구성 있지만 I/O 부하)
- **데이터베이스 세션**: MySQL, PostgreSQL 등에 저장 (영구성, 확장성)
- **분산 세션**: Redis, Memcached 등 인메모리 DB 사용 (고성능, 분산 환경)

### 보안 측면 비교

**쿠키 보안 이슈**:

- **XSS(Cross-Site Scripting)**: JavaScript로 쿠키 탈취 가능
  - 해결책: HttpOnly 속성 사용
- **CSRF(Cross-Site Request Forgery)**: 다른 사이트에서 쿠키 자동 전송
  - 해결책: SameSite 속성, CSRF 토큰 사용
- **중간자 공격**: HTTP 통신에서 쿠키 가로채기
  - 해결책: Secure 속성으로 HTTPS만 허용

**세션 보안 이슈**:

- **세션 하이재킹**: 세션 ID 탈취로 사용자 계정 접근
  - 해결책: HTTPS 사용, 세션 ID 재생성, IP 검증
- **세션 고정 공격**: 공격자가 미리 알고 있는 세션 ID 사용하도록 유도
  - 해결책: 로그인 시 새로운 세션 ID 생성
- **세션 타임아웃**: 장시간 비활성 상태에서도 세션 유지
  - 해결책: 적절한 타임아웃 설정, 슬라이딩 세션

### 실제 사용 사례와 선택 기준

**쿠키 사용 사례**:

- **자동 로그인**: 암호화된 사용자 식별 토큰 저장
- **사용자 설정**: 언어, 테마, 지역 설정 등 개인화 정보
- **장바구니**: 비회원 상태에서도 상품 정보 유지
- **추천 시스템**: 사용자 행동 패턴 분석을 위한 데이터 수집
- **광고 타겟팅**: 사용자 관심사 및 방문 이력 추적

**세션 사용 사례**:

- **로그인 상태 관리**: 인증된 사용자의 권한 정보 저장
- **임시 데이터**: 다단계 폼 작성 중간 데이터 보관
- **토큰 저장**: JWT 리프레시 토큰, CSRF 토큰 등 보안 토큰
- **게임 상태**: 실시간 게임에서 사용자 진행 상황
- **거래 정보**: 결제 과정 중 민감한 정보 임시 저장
