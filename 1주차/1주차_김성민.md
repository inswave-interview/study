## 범위

**1. 디자인 패턴**

- 1.1.1 싱글톤 팩턴
- 1.1.2 팩토리 패턴
- 1.1.3 전략 패턴
- 1.1.4 옵저버 패턴
- 1.1.5 프록시 패턴과 프록시 서버
- 1.1.6 이터레이터 패턴
- 1.1.7 노출모듈 패턴
- 1.1.8 MVC 패턴
- 1.1.9 MVP 패턴
- 1.1.10 MVVM 패턴
- **2. 프로그래밍 패러다임**
- 1.2.1 선언형과 함수형 프로다이밍
- 1.2.2 객체지향 프로그래밍
- 1.2.3 절차형 프로그래밍
- 1.2.4 패러다임의 혼합
- **3. 네트워크 기초**
- 2.1.1 처리량과 지연 시간
- 2.1.2 네트워크 토폴로지와 병목 현상
- 2.1.3 네트워크 분류
- 2.1.4 네트워크 성능 분석 명령어
- 2.1.5 네트워크 프로토콜 표준화
- **4. TCP/IP 4계층 모델**

**5. 네트워크 기기**

**6. IP주소**

**7. HTTP**

---

라이브러리 프레임워크 차이

## 디자인 패턴

디자인 패턴은 **소프트웨어 개발에서 자주 발생하는 문제들에 대한 검증된 해결책**이다
GoF가 정리한 23개 패턴을 기반으로 하며, 코드 재사용성과 유지보수성을 높이는 설계 방법론
크게 3가지

- **생성 패턴**: (싱글톤, 팩토리, 빌더)
- **구조 패턴**: (어댑터, 데코레이터, 퍼사드)
- **행위 패턴**: (옵저버, 전략, 커맨드)

---

## 싱글톤 패턴

하나의 클래스의 오직 하나의 인스턴스만 가지는 **생성** 패턴으로 보통 데이터베이스 연결 모듈에 많이 사용한다

### JS의 싱글톤 패턴

```javascript
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }
}
```

### Java 싱글톤 패턴

```java
class Singleton {
    private static class singleInstanceHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance() {
        return singleInstanceHloder.INSTANCE;
    }
}
public class HelloWorld {
    public static void main(String[] args) {
        Singleton a = Singleton.getInstance();
        Singleton b = Singleton.getInstance();
        System.out.println(a.hashCode());
        System.out.println(b.hashCode());
        if(a == b){
            System.out.println(true);
        }
    }
}
```

- 지연 초기화 홀더를 사용한 싱글톤 패턴 (가장 효율적)
- 일반적인 싱글톤 패턴 사용시 사용하지 않아도 메모리를 차지함
- Lazy Initialization 방식은 동기화 처리에 비용이 발생하는데 이런 부분인 없음 (성능상 이점)

### 장점

- 전체에서 단 하나의 인스턴스만 생성되어 메모리 사용량을 최소화하고 가비지 컬렉션 부담을 줄여준다
- 데이터베이스 연결, 로거, 캐시 등 공유 자원 관리에 매우 유용하다
- 하나의 인스턴스만 존재하기 때문에 객체의 상태가 애플리케이션 전체에서 **일관**되게 유지되어 설정 정보나 공유 데이터의 동기화 문제를 방지할 수 있다

### 단점

- TDD시 단위 테스트마다 독립적인 인스턴스를 만들기 어렵다
- 또한 강한 의존성이 발생한다
- 해결책으로 DI를 통한 디커플링이 가능하다

---

## 팩토리 패턴

객체 생성 로직을 별도 클래스로 분리하여 객체를 만드는 생성 패턴이다
상위 클래스는 중요한 뼈대를 결정하고 하위 클래스에서 객체 생성의 구체적인 내용을 결정함

---

### Java 팩토리 패턴

```java
enum CoffeeType {
	LATTE, ESPRESSO
}

abstract class Coffee {
	protected String name;
	public String getName(){
		return name;
	}
}

class Latte extends Coffee {
	public Latte(){
		name = "latte";
	}
}

class Espresso extends Coffee {
	public Espresso(){
		name = "Espresso";
	}
}

class CoffeeFactory {
	public static Coffee createCoffee(CoffeeType type){
		switch (type) {
			case LATTE:
				return new Latte();
			case ESPRESSO:
				return new Espresso();
			default:
				throw new IllegalArgumentException("Invalid coffe type: " + type);
		}
	}
}

public class main {
	public static void main(String[] args) {
		Coffee coffee = CoffeeFactory.createCoffee(CoffeeType.LATTE);
		System.out.println(coffee.getName());
	}
}
```

- enum 타입을 활용해 타입 안정성과 쓰레드세이프하게 구현한 코드
- 상속구조를 활용하여 코드 중복 방지
- 정확한 명칭은 정적 팩토리 메서드 패턴의 변형인듯 함
- 간단한 객체 생성시 생성자 대용으로 사용함 (의미있는 명칭을 부여하기 위해서)
- 이외에도 추상 팩토리 패턴, 일반 팩토리 메서드 패턴이 있다.

### 장점

- 확장성, 느슨한 결합, 코드 재사용성

### 단점

- 복잡성, 런타임시 오버헤드

### 참고자료

- [인파티스토리 - 생성자 대신 정적 팩토리 메서드 패턴을 사용하자](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90)

---

## 전략패턴

전략 패턴은 **알고리즘을 캡슐화하여 런타임에 동적으로 교체할 수 있게 하는** 행위 패턴이다

```java
import java.util.ArrayList;
import java.util.List;

interface PaymentSg {
    public void pay(int amount);
}

class KakaoPay implements PaymentSg {
    private String name;
    private String cardNumber;
    private String cvc;
    private String dateOfExpire;

    public KakaoPay(String name, String cardNumber, String cvc, String dateOfExpire) {
        this.name = name;
        this.cardNumber = cardNumber;
        this.cvc = cvc;
        this.dateOfExpire = dateOfExpire;
    }

    @Override
    public void pay(int amount) {
        System.out.println(amount + " 카카오페이로 지불함");
    }
}

class SamsungPay implements PaymentSg {
    private String email;
    private String password;

    public SamsungPay(String email, String password) {
        this.email = email;
        this.password = password;
    }

    @Override
    public void pay(int amount) {
        System.out.println(amount + " 삼성페이로 지불함");
    }
}

class Item {
    private String name;
    private int price;

    public Item(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }
}

class Cart {
    List<Item> items;

    public Cart() {
        this.items = new ArrayList<Item>();
    }

    public void addItem(Item item){
        items.add(item);
    }

    public void removeItem(Item item){
        items.remove(item);
    }

    public int calculate(){
        int sum = 0;
        for (Item item : items) {
            sum += item.getPrice();
        }
        return sum;
    }

    public void pay(PaymentSg paymentSg){ // 전략 설정
        int amount = calculate();
        paymentSg.pay(amount);
    }
}
public class Main {
    public static void main(String[] args) {
        Cart cart = new Cart();
        Item jara = new Item("jara", 100);
        Item jiri = new Item("jiri", 300);

        cart.addItem(jara);
        cart.addItem(jiri);

        cart.pay(new KakaoPay("홍길동","12341234","123","06/25"));
        cart.pay(new SamsungPay("jarajiri@naver.com","1234"));
    }
}
```

- 교재에 있는 코드로 `PaymentSg` 인터페이스를 통해 카카오페이와 삼성페이라는 서로 다른 결제 알고리즘을 구현한 코드
- `Cart` 클래스의 `pay()` 메서드가 전달받은 결제 전략 객체를 사용하여 실행 시점에 동적으로 결제 방식을 선택
- if-else 조건문 없이 객체 교체만으로 알고리즘을 변경할 수 있어 새로운 결제 수단 추가 시 기존 코드 수정 없이 확장 가능함

---

## 옵저버 패턴

객체의 **상태 변화를 관찰하다가 변화가 있을 때마다 옵저버들에게 자동으로 알림을 보내는** 행위 패턴
이벤트 기반 시스템(브라우저 DOM 이벤트, 메시지 큐) 에서 사용하며 MVC 패턴에도 사용된다

```java
import java.util.ArrayList;
import java.util.List;

interface Observer {
    void update();
}

interface Subject {
    void register(Observer obj);

    void unregister(Observer obj);

    void notifyObservers();

    Object getUpdate(Observer obj);
}

class Topic implements Subject {
    private List<Observer> observers;
    private String message;

    public Topic() {
        this.observers = new ArrayList<>();
        this.message = "";
    }

    @Override
    public void register(Observer obj) {
        if (!observers.contains(obj)) observers.add(obj);
    }

    @Override
    public void unregister(Observer obj) {
        observers.remove(obj);
    }

    @Override
    public void notifyObservers() {
        observers.forEach(Observer::update);
    }

    @Override
    public Object getUpdate(Observer obj) {
        return this.message;
    }

    public void postMessage(String msg) {
        System.out.println("Message sent to Topic:" + msg);
        this.message = msg;
        notifyObservers();
    }
}

class TopicSubscriber implements Observer {
    private String name;
    private Subject topic;

    public TopicSubscriber(Subject topic, String name) {
        this.topic = topic;
        this.name = name;
    }

    @Override
    public void update() {
        String msg = (String) topic.getUpdate(this);
        System.out.println(name + ":: got message >> " + msg);
    }
}

public class Main{
    public static void main(String[] args) {
        Topic topic = new Topic();
        Observer a = new TopicSubscriber(topic,"a");
        Observer b = new TopicSubscriber(topic,"b");
        Observer c = new TopicSubscriber(topic,"c");

        topic.register(a);
        topic.register(b);
        topic.register(c);

        topic.postMessage("아무무는 사기챔이다");

    }
}
```

- `Topic`: 메시지를 관리하고 구독자들에게 알림을 보내는 주제
- `TopicSubscriber`: 토픽을 구독하고 메시지 업데이트를 받는 구독자
- 하나의 `Topic`이 여러 `TopicSubscriber`들을 관리하여 메시지 하나가 모든 구독자에게 동시에 전달되는 일대다 구조
- `postMessage()` 호출 시 `notifyObservers()`가 자동으로 실행되어 모든 등록된 구독자들이 즉시 업데이트
- `register()`와 `unregister()` 런타임에 구독자를 추가하거나 제거할 수 있어 유연함

### 상속과 구현의 차이

**상속**

- 클래스 간의 관계로 자식 클래스가 부모 클래스의 속성과 메서드를 물려받는 것
- extended 키워드
- 코드의 재사용 목적이 강하다
- 단일상속만 지원(다이아 몬드 문제)
  구현
- 클래스와 인터페이스 인터페이스와 클래스 간의 관계로 클래스가 인터페이스에 정의된 추상 메서드들을 **반드시 구현해야 한다**
- implements 키워드
- 규격을 준수하도록 강제하는것이 목적
- 다중구현이 가능하다

---

## 프록시 패턴

실제 객체에 대한 접근을 제어하기 위해 대리자(Proxy)를 두는 구조 패턴
다양하게 사용되며 데이터 검증, 보안, 캐시, 로깅등에 사용된다
사용 예

- Node 환경에서 프록시 서버로 쓰이는 Nginx
- CDN 서비로 활용되는 CloudFare
- CORS 우회

### CORS

웹 브라우저에서 다른 도메인의 리소스에 접근할 때 발생하는 보안 정책입니다. 웹 페이지가 자신과 다른 출처(Origin)의 서버에 요청을 보낼 때 브라우저가 이를 허용할지 결정하는 메커니즘

- [인파티스토리 - CORS](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-CORS-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95-%F0%9F%91%8F)

## 이터레이터 패턴

컬렉션의 내부 구조를 노출시키지 않고 순차적으로 요소에 접근할 수 있게 하는 행위 패턴

```java
import java.util.Arrays;

// 이터레이터
interface Iterator<T> {
    boolean hasNext();

    T next();
}

// 순회가능한 컬렉션
interface Iterable<T> {
    Iterator<T> iterator();
}

// 이터레이터 구현체(숫자타입)
class NumberIterator implements Iterator<Integer> {
    private Integer[] numbers;
    private int position = 0;

    public NumberIterator(Integer[] numbers) {
        this.numbers = numbers;
    }

    @Override
    public boolean hasNext() {
        return position < numbers.length && numbers[position] != null;
    }

    @Override
    public Integer next() {
        if (!hasNext()) {
            throw new RuntimeException("더 이상 요소가 없습니다");
        }
        return numbers[position++];
    }
}

// 구체적인 컬렉션
class NumberCollection implements Iterable<Integer> {
    private Integer[] numbers;
    private int count = 0;
    private static final int MAX_SIZE = 10;

    public NumberCollection() {
        numbers = new Integer[MAX_SIZE];
    }

    public void add(Integer number) {
        if (count >= MAX_SIZE) {
            throw new RuntimeException("컬렉션이 가득 찼습니다");
        }
        numbers[count++] = number;
    }

    @Override
    public Iterator<Integer> iterator() {
        return new NumberIterator(Arrays.copyOf(numbers, count));
    }

    public int size() {
        return count;
    }
}

public class Main {
    public static void main(String[] args) {
        // 컬렉션 생성 및 데이터 추가
        NumberCollection collection = new NumberCollection();
        collection.add(10);
        collection.add(20);
        collection.add(30);
        collection.add(40);
        collection.add(50);

        Iterator<Integer> iter1 = collection.iterator();
        while (iter1.hasNext()) {
            Integer number = iter1.next();
            System.out.println("숫자: " + number);
        }
    }
}
```

## 노출모듈패턴

**클로저**를 이용해 private과 public 멤버를 구분하고, 명시적으로 노출할 것만 반환하는 JS 디자인 패턴

```javascript
// 노출모듈 패턴: IIFE + 클로저를 활용한 캡슐화
const pukuba = (() => {
  // ===== PRIVATE 영역 - 외부에서 접근 불가 =====
  const a = 1; // private 변수
  const b = () => 2; // private 함수

  // ===== PUBLIC 영역 - 클로저를 통해 private에 접근 =====
  const public = {
    c: 2, // public 변수
    d: () => 3, // public 함수
  };

  // public 객체만 반환 → 외부에서는 이것만 접근 가능
  return public;
})(); // 즉시실행함수: 정의와 동시에 실행되어 반환값을 pukuba에 할당

// ===== 사용 예제 =====
console.log(pukuba); // { c: 2, d: [Function: d] } - public 객체만 보임
console.log(pukuba.a); // undefined - private 변수 a 접근 불가
console.log(pukuba.c); // 2 - public 변수 c 접근 가능
console.log(pukuba.d()); // 3 - public 함수 d() 호출 가능
```

## MVC 패턴

애플리케이션을 Model, View, Controller 세 가지 구성 요소로 분리하여
관심사를 분리하고 코드의 재사용성과 유지보수성을 높이는 아키텍처 패턴

### Model (모델)

**데이터(상수,변수)와 비즈니스 로직**을 담당

- 데이터 저장, 조회, 수정, 삭제
- 데이터 검증 및 비즈니스 규칙
- 데이터베이스와의 상호작용

### View (뷰)

**사용자 인터페이스(UI)**를 담당

- 데이터를 사용자에게 시각적으로 표시
- 사용자의 입력을 받는 화면
- HTML, CSS, UI 컴포넌트

### Controller (컨트롤러)

**Model과 View 사이의 중재자** 역할

- 사용자 입력 처리
- Model 데이터 조작 요청
- View 업데이트 명령

---

## 선언형과 함수형 프로그래밍

**"무엇을(What)"** 할지 선언하는 프로그래밍 패러다임으로 \*_결과에 집중_. "어떻게(How)" 할지는 구체적으로 명시하지 않고 원하는 결과만 기술하는 프로그래밍 패러다임!

### 특징

추상화, 가독성, 간결성, 안정성

### 함수형 프로그래밍

함수를 일급객체로 취급하고 순수 함수와 불변성을 중시하는 선언형 프로그램의 하위 패러다임

### 일급객체

- 변수나 메서드에 함수를 할당 가능
- 함수 내부에 함수를 매개변수로 가져올 수 있음
- 함수가 함수를 반환가능

### 순수함수

출력이 입력에만 의존하는 함수

### 고차함수

함수가 함수를 매개변수로 받아 로직을 생성할 수 있는 함수

## 객체지향 프로그래밍

객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하는 프로그래밍 패러다임

### 4가지 특징

추상화, 캡슐화, 상속성, 다형성

### 오버로딩과 오버라이딩

- 같은 이름을 가진 메서드를 여러개 두는 것 : 오버로딩
- 상위 클래스로부터 상속받은 메서드를 하위 클래스에서 재정의 하는것 : 오버라이딩
- 오버라이딩은 메서드 시그니처가 같아야함

### SOLID 원칙

- 단일 책임 원칙
- 개방-폐쇄 원칙
- 리스코프 치환 원칙
- 인터페이스 분리 원칙
- 의존 역전 원칙

## 절차형 프로그래밍

**순차적으로 실행되는 명령어들의 집합**으로 프로그램을 구성하는 패러다임

---

## 네트워크 기초

네트워크란 노드와 링크가 서로 연결되어 있으며 리소스를 공유하는 집합을 의미함
노드 : 서버, 라우트, 스위치등의 네트워크 장비
링크 : 유선, 무선

### 처리량과 지연 시간

링크 내에서 성공적으로 전달된 데이터의 양(bps)
트래픽 : 특정 시점에 링크 내에 흐르는 데이터의 양
대역폭 : 주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수
지연시간(latency) : 요청이 처리되는 시간

### 토폴로지

토폴로지는 노드와 링크가 어떻게 배치되어 있는지에 대한 방식 또는 연결 형태를 의미함
트리, 버스, 스타, 링, 메시 등의 구조가 있다

### 병목 현상

전체 시스템이 성능이나 용량이 하나의 구성 요소로 인해 제한을 받는 현상

### 네트워크 분류

- LAN : 근거리 통신망
- MAN : 대도시 지역 네트워크(도시 범위)
- WAN : 광역 네트워크 (국가, 대륙 범위)

### 네트워크 성능 분석 명령어

- ping : ICMP 프로토콜, 네트워크 상태 확인 명령어
- netstat : 접속된 서비스들의 네트워크 상태 표시 명령어, 라우팅 테이블, 프로토콜, 포트번호 확인시 사용
- nslookup : 특정 도메인에 매핑된 IP를 확인하기 위해 사용
- tracert(win), traceroute(linux) : 목적지 노드 까지 네트워크 경로를 확인시 사용

### 네트워크 프로토콜 표준화

- IEEE802.3 : 유선 LAN 프로토콜

## TCP/IP 4계층 모델

### 애플리케이션 계층

FTP, HTTP, SSH, SMTP, DNS 등 응용 프로그램이 사용되는 프로토콜 계층

### 전송계층

TCP: 순서 보장, 연결지향, 수신 여부 확인 ,가상회선 패킷 교환 방식
UDP : 비순서, 수신 여부 확인 X, 데이터그램 패킷 교환 방식

### TCP 연결 과정

신뢰성 확보를 위해 3-way handshake 라는 작업을 진행함

1. SYN : 클라이언트가 서버로 ISN을 담아 SYN flag를 보냄 (SYN_SENT <-> LISTEN)
2. SYN+ACK : 서버는 SYN을 수신하고 서버의 ISN을 보냄, 승인번호로 클라이언트 ISN+1의 값을 보냄 (SYN-RECEIVED)
3. ACK : 클라이언트는 서버의 ISN+1값을 마찬가지로 승인번호로 담아 ACK flag를 보냄 (ESTABLISHED)

### TCP 연결 해제 과정

4-way handshake

1. FIN : 클라이언트가 FIN 세그먼트(TCP의 데이터 단위)를 보내고 wait 상태에 들어감
2. ACK : 서버는 클라이언트로 ACK 세그먼트를 보내고 close_wait 상태에 들어감
3. FIN : 서버의 후처리 작업 완료 후 클라이언트에게 연결 종료로 FIN 세그먼트를 보냄
4. ACK : 클라이언트를 time_wait 상태가 되고 서버로 ACK 를 보내서 서버는 종료됨
5. 클라이언트는 어느 정도 대기한 이후 연결이 종료됨

### 대기시간이 필요한 이유

지연 패킷이 발생할 경우를 대비하기 위함 (데이터 무결성 문제)

### 인터넷 계층

IP, ARP, ICMP

### 링크 계층

...
네트워크 양 진짜 너무 많은 거 아니냐
