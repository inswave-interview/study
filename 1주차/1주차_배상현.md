# 1주차\_배상현.md

## 목차

**1. 디자인 패턴**

- 1.1.1 싱글톤 팩턴
- 1.1.2 팩토리 패턴
- 1.1.3 전략 패턴
- 1.1.4 옵저버 패턴
- 1.1.5 프록시 패턴과 프록시 서버
- 1.1.6 이터레이터 패턴
- 1.1.7 노출모듈 패턴
- 1.1.8 MVC 패턴
- 1.1.9 MVP 패턴
- 1.1.10 MVVM 패턴

**2. 프로그래밍 패러다임**

- 1.2.1 선언형과 함수형 프로다이밍
- 1.2.2 객체지향 프로그래밍
- 1.2.3 절차형 프로그래밍
- 1.2.4 패러다임의 혼합

**3. 네트워크 기초**

- 2.1.1 처리량과 지연 시간
- 2.1.2 네트워크 토폴로지와 병목 현상
- 2.1.3 네트워크 분류
- 2.1.4 네트워크 성능 분석 명령어
- 2.1.5 네트워크 프로토콜 표준화

## 1. 디자인 패턴

### 1. 싱글톤 패턴 (Singleton Pattern)
- 정의: 애플리케이션에서 클래스의 인스턴스를 하나만 생성해 전역적으로 공유하는 패턴

- 예시:
```java
 public class Singleton {

    private static Singleton instance;
    
    private Singleton() {}

    public static Singleton getInstance() {

        if(instance == null) {

            instance = new Singleton();

        }

        return instance;
        
    }
}

// 사용 예시
Singleton s1 = Singleton.getInstance();
Singleton s2 = Singleton.getInstance();
System.out.println(s1 == s2); // true
```
- 활용: DB 연결 객체, 설정 관리자, 로거 등에서 활용.

### 2. 팩토리 패턴 (Factory Pattern)
- 정의: 객체 생성을 별도의 클래스/메서드로 분리해 유연성을 높이는 패턴

- 예시: 
```java
interface Animal { void speak(); }
class Dog implements Animal {
    public void speak() { System.out.println("멍멍!"); }
}
class Cat implements Animal {
    public void speak() { System.out.println("야옹!"); }
}
class AnimalFactory {
    public static Animal createAnimal(String type) {
        if(type.equals("dog")) return new Dog();
        else if(type.equals("cat")) return new Cat();
        throw new IllegalArgumentException("Unknown type");
    }
}
// 사용 예시
Animal animal = AnimalFactory.createAnimal("dog");
animal.speak(); // 멍멍!
```
- 활용: 각종 라이브러리의 객체 생성, JDBC 드라이버 등

### 3. 전략 패턴 (Strategy Pattern)
- 정의: 여러 알고리즘 중 하나를 객체로 만들어 런타임에 선택할 수 있게 하는 패턴

- 예시: 
```java
interface Strategy {
    int calculate(int a, int b);
}
class AddStrategy implements Strategy {
    public int calculate(int a, int b) { return a + b; }
}
class MultiplyStrategy implements Strategy {
    public int calculate(int a, int b) { return a * b; }
}
class Calculator {
    private Strategy strategy;
    public Calculator(Strategy strategy) {
        this.strategy = strategy;
    }
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
    public int execute(int a, int b) {
        return strategy.calculate(a, b);
    }
}
// 사용 예시
Calculator calc = new Calculator(new AddStrategy());
System.out.println(calc.execute(2, 3)); // 5
calc.setStrategy(new MultiplyStrategy());
System.out.println(calc.execute(2, 3)); // 6
```
- 활용: 결제 수단, 게임 캐릭터 AI(행동 교체), 정렬법 선택 등

### 4. 옵저버 패턴 (Observer Pattern)
- 정의: 한 객체의 상태 변화가 있을 때, 관련된 여러 객체(관찰자)들에게 자동으로 알림이 가는 패턴

- 예시: 
```java
interface Observer {
    void update(String msg);
}
class User implements Observer {
    private String name;
    public User(String name) { this.name = name; }
    public void update(String msg) {
        System.out.println(name + "에게 알림: " + msg);
    }
}
class Publisher {
    private List<Observer> observers = new ArrayList<>();
    public void addObserver(Observer o) { observers.add(o); }
    public void notifyObservers(String msg) {
        for(Observer o : observers) { o.update(msg); }
    }
}
// 사용 예시
Publisher pub = new Publisher();
pub.addObserver(new User("철수"));
pub.addObserver(new User("영희"));
pub.notifyObservers("새 소식!");
// 철수에게 알림: 새 소식!
// 영희에게 알림: 새 소식!
```
- 활용: 게시판 푸시 알림, 이벤트 리스너, GUI 리액션 등

### 5. 프록시 패턴과 프록시 서버 (Proxy Pattern)
- 정의: 실제 객체 대신 접근을 중개하거나 제어하는 대리 객체를 두는 구조

- 예시: 
```java
interface Subject {
    void request();
}
class RealSubject implements Subject {
    public void request() { System.out.println("실제 작업!"); }
}
class Proxy implements Subject {
    private RealSubject real;
    public Proxy(RealSubject real) { this.real = real; }
    public void request() {
        System.out.println("접근 제어/로깅");
        real.request();
    }
}
// 사용 예시
Subject proxy = new Proxy(new RealSubject());
proxy.request();
// 접근 제어/로깅
// 실제 작업!
```
- 활용: 캐시 프록시 서버, 방화벽, 원격 객체 호출 등

### 6. 이터레이터 패턴 (Iterator Pattern)
- 정의: 컬렉션 내부 구조를 노출하지 않고 순차적으로 요소에 접근 가능

- 예시: 
```java
List<String> list = Arrays.asList("A", "B", "C");
Iterator<String> it = list.iterator();
while(it.hasNext()) {
    System.out.println(it.next());
}
```
- 활용: 리스트/셋/맵 순회, 파일 라인 읽기 등

### 7. 노출모듈 패턴 (Revealing Module Pattern, JS)
- 정의: 모듈(클래스/함수) 내부 구현을 감추고, 일부 메서드만 외부에 노출하는 구조

- 예시: 
```javascript
var module = (function() {
    var privateVar = "secret";
    function privateFunc() { return privateVar; }
    function publicFunc() { return privateFunc(); }
    return { publicFunc };
})();
console.log(module.publicFunc()); // "secret"
```
- 활용: 라이브러리 설계, 캡슐화가 필요한 모듈 구조

### 8. MVC 패턴 (Model-View-Controller)
- 정의: Model(데이터), View(화면), Controller(제어)로 관심사를 분리하는 아키텍처

- 예시: 
```java
// Controller
@Controller
public class UserController {
    @Autowired
    private UserService userService;

    @GetMapping("/users")
    public String getUsers(Model model) {
        model.addAttribute("users", userService.getAllUsers());
        return "userList"; // View 이름 반환
    }
}
```
- 활용: Spring MVC, JSP/Servlet, 안드로이드 등

### 9. MVP 패턴 (Model-View-Presenter)
- 정의: View와 로직을 Presenter로 분리, View는 Presenter에서만 데이터를 받음

- 예시: 
```java
interface View {
    void showMessage(String msg);
}
class Presenter {
    private View view;
    Presenter(View view) { this.view = view; }
    void onClickButton() { view.showMessage("Hello MVP!"); }
}
class MainActivity implements View {
    Presenter presenter;
    MainActivity() {
        presenter = new Presenter(this);
    }
    public void showMessage(String msg) {
        System.out.println(msg);
    }
    void userAction() {
        presenter.onClickButton();
    }
}
```
- 활용: 구버전 안드로이드 앱 구조, 데스크톱 프레임워크 등

### 10. MVVM 패턴 (Model-View-ViewModel)
- 정의: View와 Model 사이에 ViewModel이 위치하고, 바인딩을 통해 데이터 자동 동기화

- 예시: 
```java
// ViewModel
public class UserViewModel extends ViewModel {
    private MutableLiveData<String> userName = new MutableLiveData<>();
    public LiveData<String> getUserName() { return userName; }
    public void setUserName(String name) { userName.setValue(name); }
}
// View(XML)
// <TextView android:text="@{viewModel.userName}" ... />
```
- 활용: Android Jetpack, WPF, iOS(SwiftUI) 등

## 2. 프로그래밍 패러다임

### 1. 선언형과 함수형 프로다이밍
- 선언형: 무엇을 할 것인지만 선언, 과정은 감춤
- 함수형: 순수 함수, 불변 데이터 활용
- 예시: 
```java
List<Integer> numbers = Arrays.asList(1,2,3,4);
List<Integer> doubled = numbers.stream()
                               .map(n -> n*2)
                               .collect(Collectors.toList());
System.out.println(doubled); // [2, 4, 6, 8]
```
- 활용: 자바 스트림 API, SQL, HTML, React 등

### 2. 객체지향 프로그래밍
- 정의: 데이터와 함수를 묶어 객체 단위로 프로그래밍
- 예시: 
```java
class Car {
    private String brand;
    public Car(String brand) { this.brand = brand; }
    public void drive() {
        System.out.println(brand + " 자동차 운전!");
    }
}
Car car = new Car("현대");
car.drive();
```
- 활용: 게임, 금융, 제조 등 복잡한 시스템

### 3. 절차형 프로그래밍
- 정의: 명령문이 순서대로 실행되는 고전적 프로그래밍 방식
- 예시: 
```java
public class Main {
    public static void main(String[] args) {
        int x = 3;
        System.out.println(x * x);
    }
}
```
- 활용: 단순 스크립트, 데이터 처리 배치, 빠른 자동화 등

### 4. 패러다임의 혼합
- 정의: 상황에 따라 여러 패러다임(객체+함수형+절차형 등) 혼합 사용
- 예시: 
```java
List<Integer> nums = Arrays.asList(1,2,3,4);
class Doubler {
    public static int process(int x) { return x * 2; }
}
List<Integer> doubled = nums.stream()
                           .map(Doubler::process)
                           .collect(Collectors.toList());
System.out.println(doubled); // [2, 4, 6, 8]
```
- 활용: 최신 Java, Kotlin Scala 등 여러 언어에서 자연스럽게 혼합

## 3. 네트워크 기초

### 1. 처리량과 지연 시간
- 처리량(Throughput): 단위 시간당 전달 가능한 데이터 양 (ex: 100Mbps)
- 지연 시간(Latency): 데이터가 목적지로 가는 데 걸리는 시간 (ms)
- 실전 사례: 고속 인터넷 (다운로드 속도), 온라인 게임 (핑/딜레이)

### 2. 네트워크 토폴로지와 병목 현상
- 토폴로지: 네트워크를 구성하는 노드/선들의 연결 구조 (버스, 스타, 링, 메시 등)
- 병목 현상: 특정 구간 또는 장비가 느려 전체 네트워크 성능 저하
- 실전 사례: 학교/회사에서 일부 스위치 문제로 전체 느려짐, 데이터센터에서 특정 허브 먹통 등

### 3. 네트워크 분류
(보류)

### 4. 네트워크 성능 분석 명령어
- ping: 연결/지연 시간 체크
```text
ping 네이버.com
```

- traceroute/tracert: 목적지까지 경로 추적
```text
tracert naver.com (Windows)
traceroute naver.com (Linux/Mac)
```

- netstat: 네트워크 포트/연결 상태 조회
```text
netstat -an
```

- iftop/nload: 리눅스 실시간 트래픽 체크 (추가 설치 필요)

### 5. 네트워크 프로토콜 표준화
- 목적: 다양한 제조사의 기기끼리 통신 가능하게 규약을 표준화
- 주요 기구: IETF(인터넷 표준), ISO(국제), IEEE(이더넷/Wi-Fi)
- OSI 7계층, TCP/IP 4계층: 주요한 표준 모델
  - 예: OSI 4계층은 TCP/UDP, 7계층은 HTTP/FTP 등