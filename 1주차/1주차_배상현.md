# 1주차\_배상현.md

## 목차

**1. 디자인 패턴**

- 1.1.1 싱글톤 팩턴
- 1.1.2 팩토리 패턴
- 1.1.3 전략 패턴
- 1.1.4 옵저버 패턴
- 1.1.5 프록시 패턴과 프록시 서버
- 1.1.6 이터레이터 패턴
- 1.1.7 노출모듈 패턴
- 1.1.8 MVC 패턴
- 1.1.9 MVP 패턴
- 1.1.10 MVVM 패턴

**2. 프로그래밍 패러다임**

- 1.2.1 선언형과 함수형 프로다이밍
- 1.2.2 객체지향 프로그래밍
- 1.2.3 절차형 프로그래밍
- 1.2.4 패러다임의 혼합

**3. 네트워크 기초**

- 2.1.1 처리량과 지연 시간
- 2.1.2 네트워크 토폴로지와 병목 현상
- 2.1.3 네트워크 분류
- 2.1.4 네트워크 성능 분석 명령어
- 2.1.5 네트워크 프로토콜 표준화

## 1. 디자인 패턴

### 1. 싱글톤 패턴 (Singleton Pattern)
- 정의: 애플리케이션에서 클래스의 인스턴스를 단 하나만 생성해 전역적으로 공유하는 패턴

- 예시:
```java
 public class Singleton {

    private static Singleton instance;
    
    private Singleton() {}

    public static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

// 사용 예시
Singleton s1 = Singleton.getInstance();
Singleton s2 = Singleton.getInstance();
System.out.println(s1 == s2); // true
```
- 장점: 
  - 메모리 낭비를 방지하고 전역적으로 접근이 용이하여 데이터 공유가 쉬움
  - 하나의 인스턴스를 사용하므로 리소스(DB 연결, 파일 등) 충돌을 방지할 수 있음
- 단점: 
  - 모듈 간의 결합도가 높아져 유지보수와 단위 테스트가 어려워질 수 있음
  - 객체 지향 설계 원칙 중 하나인 개방-폐쇄 원칙(OCP)을 위반할 가능성이 높음

- 활용: DB 연결 객체, 설정 관리자, 로거 등에서 활용.

### 2. 팩토리 패턴 (Factory Pattern)
- 정의: 객체 생성을 별도의 클래스나 메서드로 분리하여, 클라이언트 코드가 구체적인 클래스에 의존하지 않고 객체를 생성할 수 있게 하는 패턴

- 예시: 
```java
interface Animal {
     void speak(); 
}

class Dog implements Animal {
    public void speak() { 
        System.out.println("멍멍!");
    }
}

class Cat implements Animal {
    public void speak() { 
        System.out.println("야옹!"); }
}

class AnimalFactory {
    public static Animal createAnimal(String type) {
        if(type.equals("dog")) return new Dog();
        else if(type.equals("cat")) return new Cat();
        throw new IllegalArgumentException("Unknown type");
    }
}

// 사용 예시
Animal animal = AnimalFactory.createAnimal("dog");
animal.speak(); // 멍멍!
```
- 장점:
  - 객체 생성 로직이 한 곳에 모여 있어 코드의 유지보수성이 향상
  - 새로운 클래스가 추가돼도 클라이언트 코드의 수정 없이 팩토리 클래스만 수정하면 되므로 유연성과 확장성이 높아짐

- 활용: 각종 라이브러리의 객체 생성, JDBC 드라이버 등

### 3. 전략 패턴 (Strategy Pattern)
- 정의: 여러 알고리즘을 각각 별도의 클래스로 캡슐화하고, 이들을 동적으로 교체하여 사용할 수 있게 하는 패턴

- 예시: 
```java
interface Strategy {
    int calculate(int a, int b);
}

class AddStrategy implements Strategy {
    public int calculate(int a, int b) {
         return a + b; 
    }
}

class MultiplyStrategy implements Strategy {
    public int calculate(int a, int b) { 
        return a * b; 
    }
}

class Calculator {
    private Strategy strategy;
    public Calculator(Strategy strategy) {
        this.strategy = strategy;
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public int execute(int a, int b) {
        return strategy.calculate(a, b);
    }
}
// 사용 예시
Calculator calc = new Calculator(new AddStrategy());
System.out.println(calc.execute(2, 3)); // 5
calc.setStrategy(new MultiplyStrategy());
System.out.println(calc.execute(2, 3)); // 6
```
- 핵심: 무엇을 할 것인지(Context)와 어떻게 할 것인지(Strategy)를 분리하는 것이 핵심
- 장점:
  - 새로운 알고리즘이 추가되거나 기존 알고리즘이 변경되더라도, Calculator와 같은 컨텍스트 코드는 수정할 필요 없음
  - 코드의 확장성을 높여줌

- 활용: 결제 수단, 게임 캐릭터 AI(행동 교체), 정렬법 선택 등

### 4. 옵저버 패턴 (Observer Pattern)
- 정의: 한 객체(Subject, Publisher)의 상태가 변하면, 그 객체에 의존하는 여러 다른 객체(Observer, Subscriber)들에게 자동으로 알림이 전달되어 갱신되도록 하는 1:N 관계의 패턴

- 예시: 
```java
interface Observer {
    void update(String msg);
}

class User implements Observer {
    private String name;
    public User(String name) { 
        this.name = name; 
    }

    public void update(String msg) {
        System.out.println(name + "에게 알림: " + msg);
    }
}

class Publisher {
    private List<Observer> observers = new ArrayList<>();
    public void addObserver(Observer o) {
         observers.add(o); 
    }

    public void notifyObservers(String msg) {
        for(Observer o : observers) {
             o.update(msg); 
        }
    }
}

// 사용 예시
Publisher pub = new Publisher();
pub.addObserver(new User("철수"));
pub.addObserver(new User("영희"));
pub.notifyObservers("새 소식!");
// 철수에게 알림: 새 소식!
// 영희에게 알림: 새 소식!
```
- 구성 요소:
  - Subject (주제): 관찰자들을 관리(등록, 삭제)하고, 상태 변화가 있을 때 관찰자들에게 알리는 주체
  - Observer (관찰자): Subject의 상태 변화에 대한 알림을 받고, 특정 동작을 수행하는 객체
- 장점: 
  - 주제와 관찰자가 느슨하게 결합(Loose Coupling)되어 있어, 서로의 세부 구현을 알 필요 없이 상호작용 가능
  - 시스템이 유연해짐

- 활용: 게시판 푸시 알림, 이벤트 리스너, GUI 리액션 등

### 5. 프록시 패턴과 프록시 서버 (Proxy Pattern)
- 정의: 특정 객체에 대한 접근을 제어하기 위해 대리인(Proxy) 역할을 하는 객체를 두는 패턴, 이를 통해 원래 객체의 기능을 보완하거나 접근을 제어할 수 있음

- 예시: 
```java
interface Subject {
    void request();
}

class RealSubject implements Subject {
    public void request() { 
        System.out.println("실제 작업!"); 
    }
}

class Proxy implements Subject {
    private RealSubject real;
    public Proxy(RealSubject real) { 
        this.real = real;
    }
    
    public void request() {
        System.out.println("접근 제어/로깅");
        real.request();
    }
}

// 사용 예시
Subject proxy = new Proxy(new RealSubject());
proxy.request();
// 접근 제어/로깅
// 실제 작업!
```
- 프록시의 종류:
  - 보호 프록시(Protection Proxy): 특정 클라이언트만 실제 객체에 접근할 수 있도록 권한을 제어
  - 가상 프록시(Virtual Proxy): 실제 객체가 필요해지기 전까지 생성을 미루고, 필요할 때 생성하여 메모리를 절약
  - 로깅 프록시(Logging Proxy): 실제 객체의 메서드 호출 전후에 로그를 기록
- 프록시 서버: 네트워크에서 클라이언트와 서버 사이의 중계 서버를 의미. 캐싱(자주 사용하는 데이터 저장), 보안(방화벽), 접근 제어, 로깅 등의 역할을 수행하여 프록시 패턴의 개념을 네트워크 레벨에서 구현한 것

- 활용: 캐시 프록시 서버, 방화벽, 원격 객체 호출 등

### 6. 이터레이터 패턴 (Iterator Pattern)
- 정의: 컬렉션 내부 구조를 노출하지 않고 순차적으로 요소에 접근 가능

- 예시: 
```java
List<String> list = Arrays.asList("A", "B", "C");
Iterator<String> it = list.iterator();
while(it.hasNext()) {
    System.out.println(it.next());
}
```
- 핵심: 데이터 구조와 순회 알고리즘을 분리하는 것
- 장점: 
  - 클라이언트 코드는 컬렉션의 종류(ArrayList, LinkedList 등)에 상관없이 동일한 방식으로 순회 가능
  - 코드의 일관성과 재사용성을 높여줌

- 활용: 리스트/셋/맵 순회, 파일 라인 읽기 등

### 7. 노출모듈 패턴 (Revealing Module Pattern)
- 정의: JavaScript에서 즉시 실행 함수(IIFE)와 클로저를 활용하여, 특정 변수나 함수는 비공개(private)로 숨기고, 외부에 노출할 멤버들만 선택적으로 반환하는 패턴

- 예시: 
```javascript
var module = (function() {
    var privateVar = "secret";
    function privateFunc() { return privateVar; }
    function publicFunc() { return privateFunc(); }
    return { publicFunc };
})();
console.log(module.publicFunc()); // "secret"
```
- 핵심: 
  - 캡슐화를 통해 모듈 내부의 상태를 보호하고, 명확한 API만 외부의 제공하는 것이 목적
  - ES6의 모듈(import/export) 시스템이 등장하기 전까지 JavaScript에서 모듈화를 구현하던 보편적인 방법

- 활용: 라이브러리 설계, 캡슐화가 필요한 모듈 구조

### 8. MVC 패턴 (Model-View-Controller)
- 정의: Model(데이터), View(화면), Controller(제어)로 관심사를 분리하는 아키텍처

- 예시: 
```java
// Controller
@Controller
public class UserController {
    @Autowired
    private UserService userService;

    @GetMapping("/users")
    public String getUsers(Model model) {
        model.addAttribute("users", userService.getAllUsers());
        return "userList"; // View 이름 반환
    }
}
```
- 보충: 
  1. 사용자 입력: 사용자가 View를 통해 액션을 취함
  2. Controller 전달: View는 사용자 입력을 Controller에게 전달
  3. Model 업데이트: Controller는 사용자 입력을 해석해 Model의 데이터를 변경하거나 처리
  4. View 업데이트: Model의 데이터가 변경되면, View는 변경된 데이터를 반영하여 사용자에게 보여줌 (View가 Model을 직접 구독하거나, Controller를 통해 업데이트 되기도 함)

- 활용: Spring MVC, JSP/Servlet, 안드로이드 등

### 9. MVP 패턴 (Model-View-Presenter)
- 정의: MVC 패턴에서 파생되었으며, Controller 대신 Presenter가 View와 Model 사이의 중재자 역할을 함. View와 Presenter는 1:1로 강하게 연결됨

- 예시: 
```java
interface View {
    void showMessage(String msg);
}

class Presenter {
    private View view;
    Presenter(View view) { 
        this.view = view;
    }

    void onClickButton() { 
        view.showMessage("Hello MVP!"); 
    }
}

class MainActivity implements View {
    Presenter presenter;
    MainActivity() {
        presenter = new Presenter(this);
    }

    public void showMessage(String msg) {
        System.out.println(msg);
    }

    void userAction() {
        presenter.onClickButton();
    }
}
```
- 보충: 
  - 가장 큰 차이는 View와 Model의 완전한 분리. MVP에서 View는 Presenter를 통해서만 데이터를 전달받으며, Model에 대해 알지 못함
  - View는 인터페이스를 통해 완전히 수동적인(Passive) 역할을 하게 되어 단위 테스트가 MVC 패턴보다 용이해짐

- 활용: 구버전 안드로이드 앱 구조, 데스크톱 프레임워크 등

### 10. MVVM 패턴 (Model-View-ViewModel)
- 정의: View와 Model 사이에 ViewModel이 위치하고, 바인딩(Data Binding)을 통해  View와 ViewModel의 데이터를 자동으로 동기화하는 패턴

- 예시: 
```java
// ViewModel
public class UserViewModel extends ViewModel {
    private MutableLiveData<String> userName = new MutableLiveData<>();
    public LiveData<String> getUserName() { 
        return userName; 
    }

    public void setUserName(String name) { 
        userName.setValue(name); 
    }
}

// View(XML)
// <TextView android:text="@{viewModel.userName}" ... />
```
- MVP와의 차이점: 
  - Presenter 대신 ViewModel이 존재하며, View를 직접 참조하지 않음
  - 데이터 바인딩이 핵심
  - View는 ViewModel의 데이터를 바인딩하여 관찰하고 있다가, 데이터가 변경되면 별도의 코드 없이 자동으로 UI가 갱신됨
  - 이로 인해 View를 업데이트하기 위한 상용구(boilerplate) 코드가 크게 감소

- 활용: Android Jetpack, WPF, iOS(SwiftUI) 등

## 2. 프로그래밍 패러다임

### 1. 선언형과 함수형 프로다이밍
- 선언형(Declarative): "어떻게" 할 것인지(How)보다 **"무엇을" 할 것인지(What)**를 중심으로 코드를 작성. SQL, HTML, React의 JSX 등이 대표적인 예
- 함수형(Functional): 선언형 패러다임의 일종으로, 순수 함수(Pure Functions), 불변성(Immutability), 부수 효과(Side Effect) 최소화가 핵심 원칙

- 예시: 
```java
List<Integer> numbers = Arrays.asList(1,2,3,4);
List<Integer> doubled = numbers.stream()
                               .map(n -> n*2)
                               .collect(Collectors.toList());
System.out.println(doubled); // [2, 4, 6, 8]
```
- 보충: 함수형 프로그래밍은 동일한 입력에 대해 항상 동일한 출력을 반환하고 외부 상태를 변경하지 않으므로, 코드의 예측 가능성을 높이고 버그를 줄이며, 병렬 처리 환경에서 안전하게 동작함

- 활용: 자바 스트림 API, SQL, HTML, React 등

### 2. 객체지향 프로그래밍 (OOP)
- 정의:  데이터와 그 데이터를 처리하는 함수(메서드)를 하나의 '객체'로 묶어 프로그래밍하는 방식

- 예시: 
```java
class Car {
    private String brand;
    public Car(String brand) { 
        this.brand = brand; 
    }

    public void drive() {
        System.out.println(brand + " 자동차 운전!");
    }
}

Car car = new Car("현대");
car.drive();
```
- 핵심 4대 원칙
  - 캡슐화(Encapsulation): 데이터(속성)와 기능을 하나의 단위로 묶고, 외부로부터의 직접적인 접근을 제한하여 데이터를 보호
  - 추상화(Abstraction): 객체의 복잡한 내부 구현은 숨기고, 실제 사용에 필요한 핵심적인 기능만 외부에 노출
  - 상속(Inheritance): 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 재사용하고 확장할 수 있게 함
  - 다형성(Polymorphism): 동일한 이름의 메서드나 연산자가 객체의 종류에 따라 다르게 동작할 수 있게 하는 특성 (오버라이딩, 오버로딩)

- 활용: 게임, 금융, 제조 등 복잡한 시스템

### 3. 절차형 프로그래밍
- 정의: 정해진 순서에 따라 명령어들이 순차적으로 실행되는 방식으로, '프로시저(함수)'를 호출하는 방식으로 프로그램을 구성

- 예시: 
```java
public class Main {
    public static void main(String[] args) {
        int x = 3;
        System.out.println(x * x);
    }
}
```
- 보충: 
  - 데이터를 중심으로 함수를 설계하는 것이 아닌, 실행되는 절차를 중심으로 코드 작성
  - C언어가 대표적인 절차형 언어

- 활용: 단순 스크립트, 데이터 처리 배치, 빠른 자동화 등

### 4. 패러다임의 혼합
- 정의: 현대의 많은 프로그래밍 언어(Java, Python, JavaScript 등)는 특정 패러다임에 국한되지 않고 여러 패러다임의 장점을 혼합하여 사용할 수 있도록 지원함

- 예시: 
```java
List<Integer> nums = Arrays.asList(1,2,3,4);
class Doubler {
    public static int process(int x) { 
        return x * 2; 
    }
}

List<Integer> doubled = nums.stream()
                           .map(Doubler::process)
                           .collect(Collectors.toList());
System.out.println(doubled); // [2, 4, 6, 8]
```
- 보충: 
  - 예를 들어, Java에서 클래스(객체지향)를 정의하고, 그 안의 메서드에서 Stream API(함수형)를 사용하여 데이터를 처리하는 것이 패러다임 혼합의 예시
  - 상황에 가장 적합한 도구를 선택하여 코드의 가독성과 효율성을 높일 수 있음

- 활용: 최신 Java, Kotlin Scala 등 여러 언어에서 자연스럽게 혼합

## 3. 네트워크 기초

### 1. 처리량과 지연 시간
- 처리량(Throughput): 단위 시간당 성공적으로 전송된 데이터의 양 (단위: bps, bits per second)

- 지연 시간(Latency): 데이터 패킷이 출발지에서 목적지까지 도달하는 데 걸리는 시간. 응답 시간(Ping)과 유사한 개념 (단위: ms, millisecond)

- 대역폭(Bandwidth): 처리량과 자주 혼용되는 대역폭은 네트워크에서 이론적으로 전송 가능한 최대 데이터 양을 의미함.

- 예시: 대역폭은 파이프의 최대 굵기, 처리량은 실제로 그 파이프를 통해 흐르는 물의 양

- 사례: 고속 인터넷 (다운로드 속도), 온라인 게임 (핑/딜레이)

### 2. 네트워크 토폴로지와 병목 현상
- 토폴로지(Topology): 컴퓨터 네트워크의 요소들(노드, 링크 등)이 물리적으로 또는 논리적으로 연결된 방식 및 구조
  - 주요 토폴로지: 
    - 버스(Bus)형: 하나의 공통 케이블에 모든 노드가 연결
    - 스타(Star)형: 중앙의 허브나 스위치에 모든 노드가 1:1로 연결됨. 현대의 LAN 환경에서 가장 일반적
    - 링(Ring)형: 각 노드가 양옆의 두 노드와 연결되어 전체적으로 고리 모양을 이룸
    - 메시(Mesh)형: 모든 노드가 다른 모든 노드와 개별적으로 연결되어 안정성이 높음

- 병목(Bottleneck) 현상: 전체 시스템의 성능이나 처리량이 하나의 특정 구성 요소(하드웨어 또는 소프트웨어)의 제한된 성능으로 인해 저하되는 현상

- 사례: 학교/회사에서 일부 스위치 문제로 전체 느려짐, 데이터센터에서 특정 허브 먹통 등

### 3. 네트워크 분류
- 네트워크는 규모와 관리 범위에 따라 분류됨
  - LAN (Local Area Network): 근거리 통신망으로, 집, 사무실, 학교 등 제한된 지역 내의 장치들을 연결하는 네트워크. 일반적으로 스위치나 공유기를 통해 연결되며 속도가 빠름

  - MAN (Metropolitan Area Network): 대도시권 통신망으로, LAN보다는 크고 WAN보다는 작은 규모의 네트워크. 여러개의 LAN을 하나로 연결하여 도시 전체나 특정 대도시 지역에 서비스를 제공

  - WAN (Wide Area Network): 광역 통신망으로, 지리적으로 넓은 범위(국가, 대륙)에 걸쳐 있는 네트워크들을 연결함. 여러 LAN이나 MAN이 라우터를 통해 연결된 거대한 네트워크이며, 인터넷이 가장 대표적인 WAN

### 4. 네트워크 성능 분석 명령어
- ping: 특정 목적지 호스트까지 네트워크 연결이 정상적인지 확인하고, 패킷이 왕복하는 데 걸리는 시간(Latency)을 측정

- traceroute/tracert: 목적지 호스트까지 도달하는 동안 거쳐가는 모든 네트워크 경로(라우터)의 목록과 각 구간의 지연 시간을 추적

- netstat: 현재 컴퓨터의 모든 네트워크 연결 상태, 라우팅 테이블, 포트 목록 등을 표시

- iftop/nload: (리눅스에서 주로 사용) 실시간으로 네트워크 트래픽 사용량을 인터페이스별로 모니터링하는 도구

### 5. 네트워크 프로토콜 표준화
- 목적: 서로 다른 하드웨어나 소프트웨어를 사용하는 시스템끼리도 원활하게 통신할 수 있도록 공통의 약속, 즉 프로토콜을 정하는 것

- 대표적인 표준 모델: 
  - OSI 7계층: 
    - 국제표준화기구(ISO)에서 제정한 네트워크 통신 표준 모델
    - 통신 과정을 7개의 논리적인 계층으로 나눔 (물리-데이터링크-네트워크-전송-세션-표현-응용)

  - TCP/IP 4계층: 
    - OSI 모델보다 먼저 만들어져 현재 인터넷에서 사실상의 표준(De Facto Standard)으로 사용되는 모델
    - OSI 모델을 더 단순화하여 4개의 계층으로 구성
        - 4계층 (Application): HTTP, FTP, SMTP 등 (OSI 5, 6, 7계층 해당)
        - 3계층 (Transport): TCP, UDP 등 (OSI 4계층 해당)
        - 2계층 (Internet): IP, ICMP 등 (OSI 3계층 해당)
        - 1계층 (Network Interface): Ethernet, Wi-Fi 등 (OSI 1, 2계층 해당)